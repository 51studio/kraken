// Generated by opcode_generator.rb from /Users/hejian/Downloads/dev_multi_process/Source/JavaScriptCore/b3/air/AirOpcode.opcodes -- do not edit!
#ifndef AirOpcodeGenerated_h
#define AirOpcodeGenerated_h
#include "AirInstInlines.h"
#include "wtf/PrintStream.h"
namespace WTF {
using namespace JSC::B3::Air;
void printInternal(PrintStream& out, Opcode opcode)
{
    switch (opcode) {
    case Opcode::Nop:
        out.print("Nop");
        return;
    case Opcode::Add32:
        out.print("Add32");
        return;
    case Opcode::Add8:
        out.print("Add8");
        return;
    case Opcode::Add16:
        out.print("Add16");
        return;
    case Opcode::Add64:
        out.print("Add64");
        return;
    case Opcode::AddDouble:
        out.print("AddDouble");
        return;
    case Opcode::AddFloat:
        out.print("AddFloat");
        return;
    case Opcode::Sub32:
        out.print("Sub32");
        return;
    case Opcode::Sub64:
        out.print("Sub64");
        return;
    case Opcode::SubDouble:
        out.print("SubDouble");
        return;
    case Opcode::SubFloat:
        out.print("SubFloat");
        return;
    case Opcode::Neg32:
        out.print("Neg32");
        return;
    case Opcode::Neg64:
        out.print("Neg64");
        return;
    case Opcode::NegateDouble:
        out.print("NegateDouble");
        return;
    case Opcode::NegateFloat:
        out.print("NegateFloat");
        return;
    case Opcode::Mul32:
        out.print("Mul32");
        return;
    case Opcode::Mul64:
        out.print("Mul64");
        return;
    case Opcode::MultiplyAdd32:
        out.print("MultiplyAdd32");
        return;
    case Opcode::MultiplyAdd64:
        out.print("MultiplyAdd64");
        return;
    case Opcode::MultiplySub32:
        out.print("MultiplySub32");
        return;
    case Opcode::MultiplySub64:
        out.print("MultiplySub64");
        return;
    case Opcode::MultiplyNeg32:
        out.print("MultiplyNeg32");
        return;
    case Opcode::MultiplyNeg64:
        out.print("MultiplyNeg64");
        return;
    case Opcode::Div32:
        out.print("Div32");
        return;
    case Opcode::UDiv32:
        out.print("UDiv32");
        return;
    case Opcode::Div64:
        out.print("Div64");
        return;
    case Opcode::UDiv64:
        out.print("UDiv64");
        return;
    case Opcode::MulDouble:
        out.print("MulDouble");
        return;
    case Opcode::MulFloat:
        out.print("MulFloat");
        return;
    case Opcode::DivDouble:
        out.print("DivDouble");
        return;
    case Opcode::DivFloat:
        out.print("DivFloat");
        return;
    case Opcode::X86ConvertToDoubleWord32:
        out.print("X86ConvertToDoubleWord32");
        return;
    case Opcode::X86ConvertToQuadWord64:
        out.print("X86ConvertToQuadWord64");
        return;
    case Opcode::X86Div32:
        out.print("X86Div32");
        return;
    case Opcode::X86UDiv32:
        out.print("X86UDiv32");
        return;
    case Opcode::X86Div64:
        out.print("X86Div64");
        return;
    case Opcode::X86UDiv64:
        out.print("X86UDiv64");
        return;
    case Opcode::Lea32:
        out.print("Lea32");
        return;
    case Opcode::Lea64:
        out.print("Lea64");
        return;
    case Opcode::And32:
        out.print("And32");
        return;
    case Opcode::And64:
        out.print("And64");
        return;
    case Opcode::AndDouble:
        out.print("AndDouble");
        return;
    case Opcode::AndFloat:
        out.print("AndFloat");
        return;
    case Opcode::OrDouble:
        out.print("OrDouble");
        return;
    case Opcode::OrFloat:
        out.print("OrFloat");
        return;
    case Opcode::XorDouble:
        out.print("XorDouble");
        return;
    case Opcode::XorFloat:
        out.print("XorFloat");
        return;
    case Opcode::Lshift32:
        out.print("Lshift32");
        return;
    case Opcode::Lshift64:
        out.print("Lshift64");
        return;
    case Opcode::Rshift32:
        out.print("Rshift32");
        return;
    case Opcode::Rshift64:
        out.print("Rshift64");
        return;
    case Opcode::Urshift32:
        out.print("Urshift32");
        return;
    case Opcode::Urshift64:
        out.print("Urshift64");
        return;
    case Opcode::RotateRight32:
        out.print("RotateRight32");
        return;
    case Opcode::RotateRight64:
        out.print("RotateRight64");
        return;
    case Opcode::RotateLeft32:
        out.print("RotateLeft32");
        return;
    case Opcode::RotateLeft64:
        out.print("RotateLeft64");
        return;
    case Opcode::Or32:
        out.print("Or32");
        return;
    case Opcode::Or64:
        out.print("Or64");
        return;
    case Opcode::Xor32:
        out.print("Xor32");
        return;
    case Opcode::Xor64:
        out.print("Xor64");
        return;
    case Opcode::Not32:
        out.print("Not32");
        return;
    case Opcode::Not64:
        out.print("Not64");
        return;
    case Opcode::AbsDouble:
        out.print("AbsDouble");
        return;
    case Opcode::AbsFloat:
        out.print("AbsFloat");
        return;
    case Opcode::CeilDouble:
        out.print("CeilDouble");
        return;
    case Opcode::CeilFloat:
        out.print("CeilFloat");
        return;
    case Opcode::FloorDouble:
        out.print("FloorDouble");
        return;
    case Opcode::FloorFloat:
        out.print("FloorFloat");
        return;
    case Opcode::SqrtDouble:
        out.print("SqrtDouble");
        return;
    case Opcode::SqrtFloat:
        out.print("SqrtFloat");
        return;
    case Opcode::ConvertInt32ToDouble:
        out.print("ConvertInt32ToDouble");
        return;
    case Opcode::ConvertInt64ToDouble:
        out.print("ConvertInt64ToDouble");
        return;
    case Opcode::ConvertInt32ToFloat:
        out.print("ConvertInt32ToFloat");
        return;
    case Opcode::ConvertInt64ToFloat:
        out.print("ConvertInt64ToFloat");
        return;
    case Opcode::CountLeadingZeros32:
        out.print("CountLeadingZeros32");
        return;
    case Opcode::CountLeadingZeros64:
        out.print("CountLeadingZeros64");
        return;
    case Opcode::ConvertDoubleToFloat:
        out.print("ConvertDoubleToFloat");
        return;
    case Opcode::ConvertFloatToDouble:
        out.print("ConvertFloatToDouble");
        return;
    case Opcode::Move:
        out.print("Move");
        return;
    case Opcode::Swap32:
        out.print("Swap32");
        return;
    case Opcode::Swap64:
        out.print("Swap64");
        return;
    case Opcode::Move32:
        out.print("Move32");
        return;
    case Opcode::StoreZero32:
        out.print("StoreZero32");
        return;
    case Opcode::SignExtend32ToPtr:
        out.print("SignExtend32ToPtr");
        return;
    case Opcode::ZeroExtend8To32:
        out.print("ZeroExtend8To32");
        return;
    case Opcode::SignExtend8To32:
        out.print("SignExtend8To32");
        return;
    case Opcode::ZeroExtend16To32:
        out.print("ZeroExtend16To32");
        return;
    case Opcode::SignExtend16To32:
        out.print("SignExtend16To32");
        return;
    case Opcode::MoveFloat:
        out.print("MoveFloat");
        return;
    case Opcode::MoveDouble:
        out.print("MoveDouble");
        return;
    case Opcode::MoveZeroToDouble:
        out.print("MoveZeroToDouble");
        return;
    case Opcode::Move64ToDouble:
        out.print("Move64ToDouble");
        return;
    case Opcode::Move32ToFloat:
        out.print("Move32ToFloat");
        return;
    case Opcode::MoveDoubleTo64:
        out.print("MoveDoubleTo64");
        return;
    case Opcode::MoveFloatTo32:
        out.print("MoveFloatTo32");
        return;
    case Opcode::Load8:
        out.print("Load8");
        return;
    case Opcode::LoadAcq8:
        out.print("LoadAcq8");
        return;
    case Opcode::Store8:
        out.print("Store8");
        return;
    case Opcode::StoreRel8:
        out.print("StoreRel8");
        return;
    case Opcode::Load8SignedExtendTo32:
        out.print("Load8SignedExtendTo32");
        return;
    case Opcode::LoadAcq8SignedExtendTo32:
        out.print("LoadAcq8SignedExtendTo32");
        return;
    case Opcode::Load16:
        out.print("Load16");
        return;
    case Opcode::LoadAcq16:
        out.print("LoadAcq16");
        return;
    case Opcode::Load16SignedExtendTo32:
        out.print("Load16SignedExtendTo32");
        return;
    case Opcode::LoadAcq16SignedExtendTo32:
        out.print("LoadAcq16SignedExtendTo32");
        return;
    case Opcode::Store16:
        out.print("Store16");
        return;
    case Opcode::StoreRel16:
        out.print("StoreRel16");
        return;
    case Opcode::LoadAcq32:
        out.print("LoadAcq32");
        return;
    case Opcode::StoreRel32:
        out.print("StoreRel32");
        return;
    case Opcode::LoadAcq64:
        out.print("LoadAcq64");
        return;
    case Opcode::StoreRel64:
        out.print("StoreRel64");
        return;
    case Opcode::AtomicStrongCAS8:
        out.print("AtomicStrongCAS8");
        return;
    case Opcode::AtomicStrongCAS16:
        out.print("AtomicStrongCAS16");
        return;
    case Opcode::AtomicStrongCAS32:
        out.print("AtomicStrongCAS32");
        return;
    case Opcode::AtomicStrongCAS64:
        out.print("AtomicStrongCAS64");
        return;
    case Opcode::BranchAtomicStrongCAS8:
        out.print("BranchAtomicStrongCAS8");
        return;
    case Opcode::BranchAtomicStrongCAS16:
        out.print("BranchAtomicStrongCAS16");
        return;
    case Opcode::BranchAtomicStrongCAS32:
        out.print("BranchAtomicStrongCAS32");
        return;
    case Opcode::BranchAtomicStrongCAS64:
        out.print("BranchAtomicStrongCAS64");
        return;
    case Opcode::AtomicAdd8:
        out.print("AtomicAdd8");
        return;
    case Opcode::AtomicAdd16:
        out.print("AtomicAdd16");
        return;
    case Opcode::AtomicAdd32:
        out.print("AtomicAdd32");
        return;
    case Opcode::AtomicAdd64:
        out.print("AtomicAdd64");
        return;
    case Opcode::AtomicSub8:
        out.print("AtomicSub8");
        return;
    case Opcode::AtomicSub16:
        out.print("AtomicSub16");
        return;
    case Opcode::AtomicSub32:
        out.print("AtomicSub32");
        return;
    case Opcode::AtomicSub64:
        out.print("AtomicSub64");
        return;
    case Opcode::AtomicAnd8:
        out.print("AtomicAnd8");
        return;
    case Opcode::AtomicAnd16:
        out.print("AtomicAnd16");
        return;
    case Opcode::AtomicAnd32:
        out.print("AtomicAnd32");
        return;
    case Opcode::AtomicAnd64:
        out.print("AtomicAnd64");
        return;
    case Opcode::AtomicOr8:
        out.print("AtomicOr8");
        return;
    case Opcode::AtomicOr16:
        out.print("AtomicOr16");
        return;
    case Opcode::AtomicOr32:
        out.print("AtomicOr32");
        return;
    case Opcode::AtomicOr64:
        out.print("AtomicOr64");
        return;
    case Opcode::AtomicXor8:
        out.print("AtomicXor8");
        return;
    case Opcode::AtomicXor16:
        out.print("AtomicXor16");
        return;
    case Opcode::AtomicXor32:
        out.print("AtomicXor32");
        return;
    case Opcode::AtomicXor64:
        out.print("AtomicXor64");
        return;
    case Opcode::AtomicNeg8:
        out.print("AtomicNeg8");
        return;
    case Opcode::AtomicNeg16:
        out.print("AtomicNeg16");
        return;
    case Opcode::AtomicNeg32:
        out.print("AtomicNeg32");
        return;
    case Opcode::AtomicNeg64:
        out.print("AtomicNeg64");
        return;
    case Opcode::AtomicNot8:
        out.print("AtomicNot8");
        return;
    case Opcode::AtomicNot16:
        out.print("AtomicNot16");
        return;
    case Opcode::AtomicNot32:
        out.print("AtomicNot32");
        return;
    case Opcode::AtomicNot64:
        out.print("AtomicNot64");
        return;
    case Opcode::AtomicXchgAdd8:
        out.print("AtomicXchgAdd8");
        return;
    case Opcode::AtomicXchgAdd16:
        out.print("AtomicXchgAdd16");
        return;
    case Opcode::AtomicXchgAdd32:
        out.print("AtomicXchgAdd32");
        return;
    case Opcode::AtomicXchgAdd64:
        out.print("AtomicXchgAdd64");
        return;
    case Opcode::AtomicXchg8:
        out.print("AtomicXchg8");
        return;
    case Opcode::AtomicXchg16:
        out.print("AtomicXchg16");
        return;
    case Opcode::AtomicXchg32:
        out.print("AtomicXchg32");
        return;
    case Opcode::AtomicXchg64:
        out.print("AtomicXchg64");
        return;
    case Opcode::LoadLink8:
        out.print("LoadLink8");
        return;
    case Opcode::LoadLinkAcq8:
        out.print("LoadLinkAcq8");
        return;
    case Opcode::StoreCond8:
        out.print("StoreCond8");
        return;
    case Opcode::StoreCondRel8:
        out.print("StoreCondRel8");
        return;
    case Opcode::LoadLink16:
        out.print("LoadLink16");
        return;
    case Opcode::LoadLinkAcq16:
        out.print("LoadLinkAcq16");
        return;
    case Opcode::StoreCond16:
        out.print("StoreCond16");
        return;
    case Opcode::StoreCondRel16:
        out.print("StoreCondRel16");
        return;
    case Opcode::LoadLink32:
        out.print("LoadLink32");
        return;
    case Opcode::LoadLinkAcq32:
        out.print("LoadLinkAcq32");
        return;
    case Opcode::StoreCond32:
        out.print("StoreCond32");
        return;
    case Opcode::StoreCondRel32:
        out.print("StoreCondRel32");
        return;
    case Opcode::LoadLink64:
        out.print("LoadLink64");
        return;
    case Opcode::LoadLinkAcq64:
        out.print("LoadLinkAcq64");
        return;
    case Opcode::StoreCond64:
        out.print("StoreCond64");
        return;
    case Opcode::StoreCondRel64:
        out.print("StoreCondRel64");
        return;
    case Opcode::Depend32:
        out.print("Depend32");
        return;
    case Opcode::Depend64:
        out.print("Depend64");
        return;
    case Opcode::Compare32:
        out.print("Compare32");
        return;
    case Opcode::Compare64:
        out.print("Compare64");
        return;
    case Opcode::Test32:
        out.print("Test32");
        return;
    case Opcode::Test64:
        out.print("Test64");
        return;
    case Opcode::CompareDouble:
        out.print("CompareDouble");
        return;
    case Opcode::CompareFloat:
        out.print("CompareFloat");
        return;
    case Opcode::Branch8:
        out.print("Branch8");
        return;
    case Opcode::Branch32:
        out.print("Branch32");
        return;
    case Opcode::Branch64:
        out.print("Branch64");
        return;
    case Opcode::BranchTest8:
        out.print("BranchTest8");
        return;
    case Opcode::BranchTest32:
        out.print("BranchTest32");
        return;
    case Opcode::BranchTest64:
        out.print("BranchTest64");
        return;
    case Opcode::BranchDouble:
        out.print("BranchDouble");
        return;
    case Opcode::BranchFloat:
        out.print("BranchFloat");
        return;
    case Opcode::BranchAdd32:
        out.print("BranchAdd32");
        return;
    case Opcode::BranchAdd64:
        out.print("BranchAdd64");
        return;
    case Opcode::BranchMul32:
        out.print("BranchMul32");
        return;
    case Opcode::BranchMul64:
        out.print("BranchMul64");
        return;
    case Opcode::BranchSub32:
        out.print("BranchSub32");
        return;
    case Opcode::BranchSub64:
        out.print("BranchSub64");
        return;
    case Opcode::BranchNeg32:
        out.print("BranchNeg32");
        return;
    case Opcode::BranchNeg64:
        out.print("BranchNeg64");
        return;
    case Opcode::MoveConditionally32:
        out.print("MoveConditionally32");
        return;
    case Opcode::MoveConditionally64:
        out.print("MoveConditionally64");
        return;
    case Opcode::MoveConditionallyTest32:
        out.print("MoveConditionallyTest32");
        return;
    case Opcode::MoveConditionallyTest64:
        out.print("MoveConditionallyTest64");
        return;
    case Opcode::MoveConditionallyDouble:
        out.print("MoveConditionallyDouble");
        return;
    case Opcode::MoveConditionallyFloat:
        out.print("MoveConditionallyFloat");
        return;
    case Opcode::MoveDoubleConditionally32:
        out.print("MoveDoubleConditionally32");
        return;
    case Opcode::MoveDoubleConditionally64:
        out.print("MoveDoubleConditionally64");
        return;
    case Opcode::MoveDoubleConditionallyTest32:
        out.print("MoveDoubleConditionallyTest32");
        return;
    case Opcode::MoveDoubleConditionallyTest64:
        out.print("MoveDoubleConditionallyTest64");
        return;
    case Opcode::MoveDoubleConditionallyDouble:
        out.print("MoveDoubleConditionallyDouble");
        return;
    case Opcode::MoveDoubleConditionallyFloat:
        out.print("MoveDoubleConditionallyFloat");
        return;
    case Opcode::MemoryFence:
        out.print("MemoryFence");
        return;
    case Opcode::StoreFence:
        out.print("StoreFence");
        return;
    case Opcode::LoadFence:
        out.print("LoadFence");
        return;
    case Opcode::Jump:
        out.print("Jump");
        return;
    case Opcode::RetVoid:
        out.print("RetVoid");
        return;
    case Opcode::Ret32:
        out.print("Ret32");
        return;
    case Opcode::Ret64:
        out.print("Ret64");
        return;
    case Opcode::RetFloat:
        out.print("RetFloat");
        return;
    case Opcode::RetDouble:
        out.print("RetDouble");
        return;
    case Opcode::Oops:
        out.print("Oops");
        return;
    case Opcode::EntrySwitch:
        out.print("EntrySwitch");
        return;
    case Opcode::Shuffle:
        out.print("Shuffle");
        return;
    case Opcode::Patch:
        out.print("Patch");
        return;
    case Opcode::CCall:
        out.print("CCall");
        return;
    case Opcode::ColdCCall:
        out.print("ColdCCall");
        return;
    case Opcode::WasmBoundsCheck:
        out.print("WasmBoundsCheck");
        return;
    }
    RELEASE_ASSERT_NOT_REACHED();
}
} // namespace WTF
namespace JSC { namespace B3 { namespace Air {
bool Inst::isValidForm()
{
switch (this->kind.opcode) {
case Opcode::Nop:
switch (this->args.size()) {
case 0:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Opcode::Add32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Add8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Add16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Add64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AddDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AddFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Sub32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Sub64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::SubDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::SubFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Neg32:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Neg64:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::NegateDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::NegateFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Mul32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Mul64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MultiplyAdd32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MultiplyAdd64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MultiplySub32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MultiplySub64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MultiplyNeg32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MultiplyNeg64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Div32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::UDiv32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Div64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::UDiv64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MulDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MulFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::DivDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::DivFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::X86ConvertToDoubleWord32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isX86ConvertToDoubleWord32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::X86ConvertToQuadWord64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isX86ConvertToQuadWord64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::X86Div32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!isX86Div32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::X86UDiv32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!isX86UDiv32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::X86Div64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!isX86Div64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::X86UDiv64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!isX86UDiv64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Lea32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (args[0].isStack() && args[0].stackSlot()->isSpill())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Lea64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (args[0].isStack() && args[0].stackSlot()->isSpill())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::And32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::BitImm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!Arg::isValidBitImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::And64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
#if USE(JSVALUE64)
case Arg::BitImm64:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!Arg::isValidBitImm64Form(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
#endif // USE(JSVALUE64)
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AndDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AndFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::OrDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::OrFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::XorDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::XorFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Lshift32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isLshift32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Lshift64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isLshift64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Rshift32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isRshift32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Rshift64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isRshift64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Urshift32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isUrshift32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Urshift64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isUrshift64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::RotateRight32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isRotateRight32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::RotateRight64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isRotateRight64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::RotateLeft32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isRotateLeft32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::RotateLeft64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isRotateLeft64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Or32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::BitImm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!Arg::isValidBitImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Or64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
#if USE(JSVALUE64)
case Arg::BitImm64:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!Arg::isValidBitImm64Form(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
#endif // USE(JSVALUE64)
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Xor32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::BitImm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!Arg::isValidBitImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Xor64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
#if USE(JSVALUE64)
case Arg::BitImm64:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!Arg::isValidBitImm64Form(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
#endif // USE(JSVALUE64)
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Not32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Not64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AbsDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AbsFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::CeilDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::CeilFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::FloorDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::FloorFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::SqrtDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::SqrtFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ConvertInt32ToDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ConvertInt64ToDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ConvertInt32ToFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ConvertInt64ToFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::CountLeadingZeros32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::CountLeadingZeros64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ConvertDoubleToFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ConvertFloatToDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Move:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Index:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), pointerWidth()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
#if USE(JSVALUE64)
case Arg::BigImm:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
#endif // USE(JSVALUE64)
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), pointerWidth()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Swap32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Swap64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Move32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Index:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreZero32:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Index:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::SignExtend32ToPtr:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ZeroExtend8To32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width8))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::SignExtend8To32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width8))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ZeroExtend16To32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width16))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::SignExtend16To32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width16))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Index:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Index:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveZeroToDouble:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Move64ToDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Move32ToFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveDoubleTo64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveFloatTo32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Load8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width8))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadAcq8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width8))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Store8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Index:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreRel8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::SimpleAddr:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Load8SignedExtendTo32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width8))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadAcq8SignedExtendTo32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width8))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Load16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width16))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadAcq16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width16))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Load16SignedExtendTo32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width16))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadAcq16SignedExtendTo32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width16))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Store16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Index:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreRel16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::SimpleAddr:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadAcq32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreRel32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::SimpleAddr:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadAcq64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreRel64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::SimpleAddr:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicStrongCAS8:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::StatusCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[3].offset()))
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!isAtomicStrongCAS8Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[3].scale(), args[3].offset(), Width8))
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!isAtomicStrongCAS8Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
if (!isAtomicStrongCAS8Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[2].scale(), args[2].offset(), Width8))
OPGEN_RETURN(false);
if (!isAtomicStrongCAS8Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicStrongCAS16:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::StatusCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[3].offset()))
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!isAtomicStrongCAS16Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[3].scale(), args[3].offset(), Width16))
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!isAtomicStrongCAS16Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
if (!isAtomicStrongCAS16Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[2].scale(), args[2].offset(), Width16))
OPGEN_RETURN(false);
if (!isAtomicStrongCAS16Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicStrongCAS32:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::StatusCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[3].offset()))
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!isAtomicStrongCAS32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[3].scale(), args[3].offset(), Width32))
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!isAtomicStrongCAS32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
if (!isAtomicStrongCAS32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[2].scale(), args[2].offset(), Width32))
OPGEN_RETURN(false);
if (!isAtomicStrongCAS32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicStrongCAS64:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::StatusCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[3].offset()))
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!isAtomicStrongCAS64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[3].scale(), args[3].offset(), Width64))
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!isAtomicStrongCAS64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
if (!isAtomicStrongCAS64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[2].scale(), args[2].offset(), Width64))
OPGEN_RETURN(false);
if (!isAtomicStrongCAS64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchAtomicStrongCAS8:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::StatusCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[3].offset()))
OPGEN_RETURN(false);
if (!isBranchAtomicStrongCAS8Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[3].scale(), args[3].offset(), Width8))
OPGEN_RETURN(false);
if (!isBranchAtomicStrongCAS8Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchAtomicStrongCAS16:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::StatusCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[3].offset()))
OPGEN_RETURN(false);
if (!isBranchAtomicStrongCAS16Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[3].scale(), args[3].offset(), Width16))
OPGEN_RETURN(false);
if (!isBranchAtomicStrongCAS16Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchAtomicStrongCAS32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::StatusCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[3].offset()))
OPGEN_RETURN(false);
if (!isBranchAtomicStrongCAS32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[3].scale(), args[3].offset(), Width32))
OPGEN_RETURN(false);
if (!isBranchAtomicStrongCAS32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchAtomicStrongCAS64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::StatusCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[3].offset()))
OPGEN_RETURN(false);
if (!isBranchAtomicStrongCAS64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[3].scale(), args[3].offset(), Width64))
OPGEN_RETURN(false);
if (!isBranchAtomicStrongCAS64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAdd8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAdd16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAdd32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAdd64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicSub8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicSub16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicSub32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicSub64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAnd8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAnd16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAnd32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAnd64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicOr8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicOr16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicOr32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicOr64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXor8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXor16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXor32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXor64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNeg8:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNeg16:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNeg32:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNeg64:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNot8:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNot16:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNot32:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNot64:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchgAdd8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchgAdd16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchgAdd32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchgAdd64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchg8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchg16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchg32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchg64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadLink8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadLinkAcq8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreCond8:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreCondRel8:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadLink16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadLinkAcq16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreCond16:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreCondRel16:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadLink32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadLinkAcq32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreCond32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreCondRel32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadLink64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadLinkAcq64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreCond64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreCondRel64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Depend32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Depend64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Compare32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Compare64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Test32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::BitImm:
switch (this->args[3].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidBitImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Test64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::CompareDouble:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::CompareFloat:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Branch8:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Branch32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Imm:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Branch64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchTest8:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::BitImm:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidBitImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::BitImm:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
if (!Arg::isValidBitImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchTest32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::BitImm:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidBitImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::BitImm:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidBitImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::BitImm:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
if (!Arg::isValidBitImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchTest64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
#if USE(JSVALUE64)
case Arg::BitImm64:
#if CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidBitImm64Form(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
#endif // USE(JSVALUE64)
case Arg::BitImm:
#if CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidBitImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::BitImm:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidBitImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::BitImm:
#if CPU(X86_64)
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
if (!Arg::isValidBitImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchAdd32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchAdd64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchMul32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 4:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 6:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchMul64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 6:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchSub32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchSub64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchNeg32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchNeg64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveConditionally32:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 6:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveConditionally64:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 6:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveConditionallyTest32:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 6:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::BitImm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidBitImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveConditionallyTest64:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 6:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveConditionallyDouble:
switch (this->args.size()) {
case 6:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 5:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveConditionallyFloat:
switch (this->args.size()) {
case 6:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 5:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionally32:
switch (this->args.size()) {
case 6:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionally64:
switch (this->args.size()) {
case 6:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionallyTest32:
switch (this->args.size()) {
case 6:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::BitImm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidBitImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionallyTest64:
switch (this->args.size()) {
case 6:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionallyDouble:
switch (this->args.size()) {
case 6:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionallyFloat:
switch (this->args.size()) {
case 6:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MemoryFence:
switch (this->args.size()) {
case 0:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Opcode::StoreFence:
switch (this->args.size()) {
case 0:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Opcode::LoadFence:
switch (this->args.size()) {
case 0:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Opcode::Jump:
switch (this->args.size()) {
case 0:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Opcode::RetVoid:
switch (this->args.size()) {
case 0:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Opcode::Ret32:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Ret64:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::RetFloat:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::RetDouble:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Oops:
switch (this->args.size()) {
case 0:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Opcode::EntrySwitch:
OPGEN_RETURN(EntrySwitchCustom::isValidForm(*this));
break;
case Opcode::Shuffle:
OPGEN_RETURN(ShuffleCustom::isValidForm(*this));
break;
case Opcode::Patch:
OPGEN_RETURN(PatchCustom::isValidForm(*this));
break;
case Opcode::CCall:
OPGEN_RETURN(CCallCustom::isValidForm(*this));
break;
case Opcode::ColdCCall:
OPGEN_RETURN(ColdCCallCustom::isValidForm(*this));
break;
case Opcode::WasmBoundsCheck:
OPGEN_RETURN(WasmBoundsCheckCustom::isValidForm(*this));
break;
default:
break;
}
return false;
}
bool Inst::admitsStack(unsigned argIndex)
{
switch (kind.opcode) {
case Opcode::Nop:
switch (argIndex) {
default:
break;
}
break;
case Opcode::Add32:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
case Arg::Tmp:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Add8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Add16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Add64:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
case Arg::Tmp:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AddDouble:
switch (argIndex) {
case 0:
switch (args.size()) {
case 3:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AddFloat:
switch (argIndex) {
case 0:
switch (args.size()) {
case 3:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Sub32:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
case Arg::Tmp:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Sub64:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
case Arg::Tmp:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::SubDouble:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::SubFloat:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Neg32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Neg64:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::NegateDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::NegateFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Mul32:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Imm:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Mul64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MultiplyAdd32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MultiplyAdd64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MultiplySub32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MultiplySub64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MultiplyNeg32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MultiplyNeg64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Div32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::UDiv32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Div64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::UDiv64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MulDouble:
switch (argIndex) {
case 0:
switch (args.size()) {
case 3:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MulFloat:
switch (argIndex) {
case 0:
switch (args.size()) {
case 3:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::DivDouble:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::DivFloat:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::X86ConvertToDoubleWord32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::X86ConvertToQuadWord64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::X86Div32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::X86UDiv32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::X86Div64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::X86UDiv64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Lea32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Lea64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::And32:
switch (argIndex) {
case 0:
switch (args.size()) {
case 3:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::BitImm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::BitImm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::And64:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AndDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AndFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::OrDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::OrFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::XorDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::XorFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Lshift32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Lshift64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Rshift32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Rshift64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Urshift32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Urshift64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::RotateRight32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::RotateRight64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::RotateLeft32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::RotateLeft64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Or32:
switch (argIndex) {
case 0:
switch (args.size()) {
case 3:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::BitImm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::BitImm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Or64:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Xor32:
switch (argIndex) {
case 0:
switch (args.size()) {
case 3:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::BitImm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::BitImm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Xor64:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
case Arg::Imm:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
case Arg::Tmp:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Not32:
switch (argIndex) {
case 0:
switch (args.size()) {
case 1:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Not64:
switch (argIndex) {
case 0:
switch (args.size()) {
case 1:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AbsDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AbsFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::CeilDouble:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::CeilFloat:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::FloorDouble:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::FloorFloat:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::SqrtDouble:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::SqrtFloat:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::ConvertInt32ToDouble:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::ConvertInt64ToDouble:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::ConvertInt32ToFloat:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::ConvertInt64ToFloat:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::CountLeadingZeros32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::CountLeadingZeros64:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::ConvertDoubleToFloat:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::ConvertFloatToDouble:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Move:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
#if USE(JSVALUE64)
case Arg::BigImm:
break;
#endif // USE(JSVALUE64)
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
OPGEN_RETURN(true);
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
#if USE(JSVALUE64)
case Arg::BigImm:
break;
#endif // USE(JSVALUE64)
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Swap32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Swap64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Move32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
case Arg::Imm:
break;
default:
break;
}
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
OPGEN_RETURN(true);
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreZero32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
OPGEN_RETURN(true);
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::SignExtend32ToPtr:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::ZeroExtend8To32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::SignExtend8To32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::ZeroExtend16To32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::SignExtend16To32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveFloat:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
OPGEN_RETURN(true);
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveDouble:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
OPGEN_RETURN(true);
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveZeroToDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Move64ToDouble:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Move32ToFloat:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveDoubleTo64:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveFloatTo32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Load8:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadAcq8:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
case Arg::SimpleAddr:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Store8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Index:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Index:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreRel8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Index:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::SimpleAddr:
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Index:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Load8SignedExtendTo32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadAcq8SignedExtendTo32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
case Arg::SimpleAddr:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Load16:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadAcq16:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
case Arg::SimpleAddr:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Load16SignedExtendTo32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadAcq16SignedExtendTo32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
case Arg::SimpleAddr:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Store16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Index:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Index:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreRel16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Index:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::SimpleAddr:
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Index:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadAcq32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
case Arg::SimpleAddr:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::StoreRel32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
case Arg::SimpleAddr:
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadAcq64:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
case Arg::SimpleAddr:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::StoreRel64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
case Arg::SimpleAddr:
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicStrongCAS8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (args.size()) {
case 5:
switch (args[0].kind()) {
case Arg::StatusCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[4].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AtomicStrongCAS16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (args.size()) {
case 5:
switch (args[0].kind()) {
case Arg::StatusCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[4].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AtomicStrongCAS32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (args.size()) {
case 5:
switch (args[0].kind()) {
case Arg::StatusCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[4].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AtomicStrongCAS64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (args.size()) {
case 5:
switch (args[0].kind()) {
case Arg::StatusCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchAtomicStrongCAS8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
switch (args[0].kind()) {
case Arg::StatusCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchAtomicStrongCAS16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
switch (args[0].kind()) {
case Arg::StatusCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchAtomicStrongCAS32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
switch (args[0].kind()) {
case Arg::StatusCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchAtomicStrongCAS64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
switch (args[0].kind()) {
case Arg::StatusCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAdd8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAdd16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAdd32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAdd64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicSub8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicSub16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicSub32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicSub64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAnd8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAnd16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAnd32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAnd64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicOr8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicOr16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicOr32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicOr64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXor8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXor16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXor32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXor64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNeg8:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNeg16:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNeg32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNeg64:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNot8:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNot16:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNot32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNot64:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchgAdd8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchgAdd16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchgAdd32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchgAdd64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchg8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchg16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchg32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchg64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadLink8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadLinkAcq8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::StoreCond8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::StoreCondRel8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadLink16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadLinkAcq16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::StoreCond16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::StoreCondRel16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadLink32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadLinkAcq32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::StoreCond32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::StoreCondRel32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadLink64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadLinkAcq64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::StoreCond64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::StoreCondRel64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Depend32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Depend64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Compare32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Compare64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Test32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Imm:
switch (args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Tmp:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Test64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::CompareDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::CompareFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Branch8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::RelCond:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Branch32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::RelCond:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (args[0].kind()) {
case Arg::RelCond:
switch (args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Branch64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::RelCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (args[0].kind()) {
case Arg::RelCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchTest8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::BitImm:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchTest32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::BitImm:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchTest64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::BitImm:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchAdd32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args.size()) {
case 4:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
switch (args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (args.size()) {
case 4:
switch (args[0].kind()) {
case Arg::ResCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (args[0].kind()) {
case Arg::ResCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchAdd64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args.size()) {
case 4:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
switch (args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Imm:
break;
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (args.size()) {
case 4:
switch (args[0].kind()) {
case Arg::ResCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchMul32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchMul64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchSub32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (args[0].kind()) {
case Arg::ResCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchSub64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchNeg32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchNeg64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveConditionally32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveConditionally64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveConditionallyTest32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveConditionallyTest64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveConditionallyDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveConditionallyFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionally32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::RelCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Imm:
switch (args[3].kind()) {
case Arg::Tmp:
switch (args[4].kind()) {
case Arg::Tmp:
switch (args[5].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Tmp:
switch (args[3].kind()) {
case Arg::Tmp:
switch (args[4].kind()) {
case Arg::Tmp:
switch (args[5].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (args[0].kind()) {
case Arg::RelCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[3].kind()) {
case Arg::Tmp:
switch (args[4].kind()) {
case Arg::Tmp:
switch (args[5].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionally64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::RelCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
switch (args[3].kind()) {
case Arg::Tmp:
switch (args[4].kind()) {
case Arg::Tmp:
switch (args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (args[3].kind()) {
case Arg::Tmp:
switch (args[4].kind()) {
case Arg::Tmp:
switch (args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (args[0].kind()) {
case Arg::RelCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[3].kind()) {
case Arg::Tmp:
switch (args[4].kind()) {
case Arg::Tmp:
switch (args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionallyTest32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Imm:
switch (args[3].kind()) {
case Arg::Tmp:
switch (args[4].kind()) {
case Arg::Tmp:
switch (args[5].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionallyTest64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Imm:
switch (args[3].kind()) {
case Arg::Tmp:
switch (args[4].kind()) {
case Arg::Tmp:
switch (args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Tmp:
switch (args[3].kind()) {
case Arg::Tmp:
switch (args[4].kind()) {
case Arg::Tmp:
switch (args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionallyDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionallyFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MemoryFence:
switch (argIndex) {
default:
break;
}
break;
case Opcode::StoreFence:
switch (argIndex) {
default:
break;
}
break;
case Opcode::LoadFence:
switch (argIndex) {
default:
break;
}
break;
case Opcode::Jump:
switch (argIndex) {
default:
break;
}
break;
case Opcode::RetVoid:
switch (argIndex) {
default:
break;
}
break;
case Opcode::Ret32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Ret64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::RetFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::RetDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Oops:
switch (argIndex) {
default:
break;
}
break;
case Opcode::EntrySwitch:
OPGEN_RETURN(EntrySwitchCustom::admitsStack(*this, argIndex));
break;
case Opcode::Shuffle:
OPGEN_RETURN(ShuffleCustom::admitsStack(*this, argIndex));
break;
case Opcode::Patch:
OPGEN_RETURN(PatchCustom::admitsStack(*this, argIndex));
break;
case Opcode::CCall:
OPGEN_RETURN(CCallCustom::admitsStack(*this, argIndex));
break;
case Opcode::ColdCCall:
OPGEN_RETURN(ColdCCallCustom::admitsStack(*this, argIndex));
break;
case Opcode::WasmBoundsCheck:
OPGEN_RETURN(WasmBoundsCheckCustom::admitsStack(*this, argIndex));
break;
default:
break;
}
return false;
}
bool Inst::isTerminal()
{
switch (kind.opcode) {
case Opcode::BranchAtomicStrongCAS8:
case Opcode::BranchAtomicStrongCAS16:
case Opcode::BranchAtomicStrongCAS32:
case Opcode::BranchAtomicStrongCAS64:
case Opcode::Branch8:
case Opcode::Branch32:
case Opcode::Branch64:
case Opcode::BranchTest8:
case Opcode::BranchTest32:
case Opcode::BranchTest64:
case Opcode::BranchDouble:
case Opcode::BranchFloat:
case Opcode::BranchAdd32:
case Opcode::BranchAdd64:
case Opcode::BranchMul32:
case Opcode::BranchMul64:
case Opcode::BranchSub32:
case Opcode::BranchSub64:
case Opcode::BranchNeg32:
case Opcode::BranchNeg64:
case Opcode::Jump:
case Opcode::RetVoid:
case Opcode::Ret32:
case Opcode::Ret64:
case Opcode::RetFloat:
case Opcode::RetDouble:
case Opcode::Oops:
return true;
case Opcode::EntrySwitch:
return EntrySwitchCustom::isTerminal(*this);
case Opcode::Shuffle:
return ShuffleCustom::isTerminal(*this);
case Opcode::Patch:
return PatchCustom::isTerminal(*this);
case Opcode::CCall:
return CCallCustom::isTerminal(*this);
case Opcode::ColdCCall:
return ColdCCallCustom::isTerminal(*this);
case Opcode::WasmBoundsCheck:
return WasmBoundsCheckCustom::isTerminal(*this);
default:
return false;
}
}
bool Inst::hasNonArgNonControlEffects()
{
if (kind.traps)
return true;
switch (kind.opcode) {
case Opcode::LoadAcq8:
case Opcode::StoreRel8:
case Opcode::LoadAcq8SignedExtendTo32:
case Opcode::LoadAcq16:
case Opcode::LoadAcq16SignedExtendTo32:
case Opcode::StoreRel16:
case Opcode::LoadAcq32:
case Opcode::StoreRel32:
case Opcode::LoadAcq64:
case Opcode::StoreRel64:
case Opcode::AtomicStrongCAS8:
case Opcode::AtomicStrongCAS16:
case Opcode::AtomicStrongCAS32:
case Opcode::AtomicStrongCAS64:
case Opcode::BranchAtomicStrongCAS8:
case Opcode::BranchAtomicStrongCAS16:
case Opcode::BranchAtomicStrongCAS32:
case Opcode::BranchAtomicStrongCAS64:
case Opcode::AtomicAdd8:
case Opcode::AtomicAdd16:
case Opcode::AtomicAdd32:
case Opcode::AtomicAdd64:
case Opcode::AtomicSub8:
case Opcode::AtomicSub16:
case Opcode::AtomicSub32:
case Opcode::AtomicSub64:
case Opcode::AtomicAnd8:
case Opcode::AtomicAnd16:
case Opcode::AtomicAnd32:
case Opcode::AtomicAnd64:
case Opcode::AtomicOr8:
case Opcode::AtomicOr16:
case Opcode::AtomicOr32:
case Opcode::AtomicOr64:
case Opcode::AtomicXor8:
case Opcode::AtomicXor16:
case Opcode::AtomicXor32:
case Opcode::AtomicXor64:
case Opcode::AtomicNeg8:
case Opcode::AtomicNeg16:
case Opcode::AtomicNeg32:
case Opcode::AtomicNeg64:
case Opcode::AtomicNot8:
case Opcode::AtomicNot16:
case Opcode::AtomicNot32:
case Opcode::AtomicNot64:
case Opcode::AtomicXchgAdd8:
case Opcode::AtomicXchgAdd16:
case Opcode::AtomicXchgAdd32:
case Opcode::AtomicXchgAdd64:
case Opcode::AtomicXchg8:
case Opcode::AtomicXchg16:
case Opcode::AtomicXchg32:
case Opcode::AtomicXchg64:
case Opcode::LoadLink8:
case Opcode::LoadLinkAcq8:
case Opcode::StoreCond8:
case Opcode::StoreCondRel8:
case Opcode::LoadLink16:
case Opcode::LoadLinkAcq16:
case Opcode::StoreCond16:
case Opcode::StoreCondRel16:
case Opcode::LoadLink32:
case Opcode::LoadLinkAcq32:
case Opcode::StoreCond32:
case Opcode::StoreCondRel32:
case Opcode::LoadLink64:
case Opcode::LoadLinkAcq64:
case Opcode::StoreCond64:
case Opcode::StoreCondRel64:
case Opcode::MemoryFence:
case Opcode::StoreFence:
case Opcode::LoadFence:
return true;
case Opcode::EntrySwitch:
return EntrySwitchCustom::hasNonArgNonControlEffects(*this);
case Opcode::Shuffle:
return ShuffleCustom::hasNonArgNonControlEffects(*this);
case Opcode::Patch:
return PatchCustom::hasNonArgNonControlEffects(*this);
case Opcode::CCall:
return CCallCustom::hasNonArgNonControlEffects(*this);
case Opcode::ColdCCall:
return ColdCCallCustom::hasNonArgNonControlEffects(*this);
case Opcode::WasmBoundsCheck:
return WasmBoundsCheckCustom::hasNonArgNonControlEffects(*this);
default:
return false;
}
}
bool Inst::hasNonArgEffects()
{
if (kind.traps)
return true;
switch (kind.opcode) {
case Opcode::LoadAcq8:
case Opcode::StoreRel8:
case Opcode::LoadAcq8SignedExtendTo32:
case Opcode::LoadAcq16:
case Opcode::LoadAcq16SignedExtendTo32:
case Opcode::StoreRel16:
case Opcode::LoadAcq32:
case Opcode::StoreRel32:
case Opcode::LoadAcq64:
case Opcode::StoreRel64:
case Opcode::AtomicStrongCAS8:
case Opcode::AtomicStrongCAS16:
case Opcode::AtomicStrongCAS32:
case Opcode::AtomicStrongCAS64:
case Opcode::BranchAtomicStrongCAS8:
case Opcode::BranchAtomicStrongCAS16:
case Opcode::BranchAtomicStrongCAS32:
case Opcode::BranchAtomicStrongCAS64:
case Opcode::AtomicAdd8:
case Opcode::AtomicAdd16:
case Opcode::AtomicAdd32:
case Opcode::AtomicAdd64:
case Opcode::AtomicSub8:
case Opcode::AtomicSub16:
case Opcode::AtomicSub32:
case Opcode::AtomicSub64:
case Opcode::AtomicAnd8:
case Opcode::AtomicAnd16:
case Opcode::AtomicAnd32:
case Opcode::AtomicAnd64:
case Opcode::AtomicOr8:
case Opcode::AtomicOr16:
case Opcode::AtomicOr32:
case Opcode::AtomicOr64:
case Opcode::AtomicXor8:
case Opcode::AtomicXor16:
case Opcode::AtomicXor32:
case Opcode::AtomicXor64:
case Opcode::AtomicNeg8:
case Opcode::AtomicNeg16:
case Opcode::AtomicNeg32:
case Opcode::AtomicNeg64:
case Opcode::AtomicNot8:
case Opcode::AtomicNot16:
case Opcode::AtomicNot32:
case Opcode::AtomicNot64:
case Opcode::AtomicXchgAdd8:
case Opcode::AtomicXchgAdd16:
case Opcode::AtomicXchgAdd32:
case Opcode::AtomicXchgAdd64:
case Opcode::AtomicXchg8:
case Opcode::AtomicXchg16:
case Opcode::AtomicXchg32:
case Opcode::AtomicXchg64:
case Opcode::LoadLink8:
case Opcode::LoadLinkAcq8:
case Opcode::StoreCond8:
case Opcode::StoreCondRel8:
case Opcode::LoadLink16:
case Opcode::LoadLinkAcq16:
case Opcode::StoreCond16:
case Opcode::StoreCondRel16:
case Opcode::LoadLink32:
case Opcode::LoadLinkAcq32:
case Opcode::StoreCond32:
case Opcode::StoreCondRel32:
case Opcode::LoadLink64:
case Opcode::LoadLinkAcq64:
case Opcode::StoreCond64:
case Opcode::StoreCondRel64:
case Opcode::Branch8:
case Opcode::Branch32:
case Opcode::Branch64:
case Opcode::BranchTest8:
case Opcode::BranchTest32:
case Opcode::BranchTest64:
case Opcode::BranchDouble:
case Opcode::BranchFloat:
case Opcode::BranchAdd32:
case Opcode::BranchAdd64:
case Opcode::BranchMul32:
case Opcode::BranchMul64:
case Opcode::BranchSub32:
case Opcode::BranchSub64:
case Opcode::BranchNeg32:
case Opcode::BranchNeg64:
case Opcode::MemoryFence:
case Opcode::StoreFence:
case Opcode::LoadFence:
case Opcode::Jump:
case Opcode::RetVoid:
case Opcode::Ret32:
case Opcode::Ret64:
case Opcode::RetFloat:
case Opcode::RetDouble:
case Opcode::Oops:
return true;
case Opcode::EntrySwitch:
return EntrySwitchCustom::hasNonArgEffects(*this);
case Opcode::Shuffle:
return ShuffleCustom::hasNonArgEffects(*this);
case Opcode::Patch:
return PatchCustom::hasNonArgEffects(*this);
case Opcode::CCall:
return CCallCustom::hasNonArgEffects(*this);
case Opcode::ColdCCall:
return ColdCCallCustom::hasNonArgEffects(*this);
case Opcode::WasmBoundsCheck:
return WasmBoundsCheckCustom::hasNonArgEffects(*this);
default:
return false;
}
}
CCallHelpers::Jump Inst::generate(CCallHelpers& jit, GenerationContext& context)
{
UNUSED_PARAM(jit);
UNUSED_PARAM(context);
CCallHelpers::Jump result;
switch (this->kind.opcode) {
case Opcode::Nop:
jit.nop();
OPGEN_RETURN(result);
break;
break;
case Opcode::Add32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
jit.add32(args[0].asTrustedImm32(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Tmp:
jit.add32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.add32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.add32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.add32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.add32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.add32(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
jit.add32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.add32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.add32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Add8:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.add8(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.add8(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.add8(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.add8(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Add16:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.add16(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.add16(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.add16(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.add16(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Add64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.add64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.add64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.add64(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.add64(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.add64(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.add64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.add64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.add64(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
jit.add64(args[0].asTrustedImm32(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.add64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AddDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.addDouble(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.addDouble(args[0].fpr(), args[1].asAddress(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.addDouble(args[0].asAddress(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.addDouble(args[0].asBaseIndex(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.addDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.addDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AddFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.addFloat(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.addFloat(args[0].fpr(), args[1].asAddress(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.addFloat(args[0].asAddress(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.addFloat(args[0].asBaseIndex(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.addFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.addFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Sub32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.sub32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.sub32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.sub32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.sub32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.sub32(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
jit.sub32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.sub32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.sub32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 3:
#if CPU(ARM64)
jit.sub32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::Sub64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.sub64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.sub64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.sub64(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.sub64(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.sub64(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.sub64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.sub64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.sub64(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 3:
#if CPU(ARM64)
jit.sub64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::SubDouble:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
jit.subDouble(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.subDouble(args[0].fpr(), args[1].asAddress(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.subDouble(args[0].fpr(), args[1].asBaseIndex(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.subDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.subDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::SubFloat:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
jit.subFloat(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.subFloat(args[0].fpr(), args[1].asAddress(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.subFloat(args[0].fpr(), args[1].asBaseIndex(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.subFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.subFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Neg32:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.neg32(args[0].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.neg32(args[0].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.neg32(args[0].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::Neg64:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.neg64(args[0].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.neg64(args[0].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.neg64(args[0].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::NegateDouble:
#if CPU(ARM64)
jit.negateDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::NegateFloat:
#if CPU(ARM64)
jit.negateFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::Mul32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.mul32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.mul32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.mul32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.mul32(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.mul32(args[0].asAddress(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
jit.mul32(args[0].asTrustedImm32(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Mul64:
switch (this->args.size()) {
case 2:
#if CPU(X86_64) || CPU(ARM64)
jit.mul64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 3:
jit.mul64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::MultiplyAdd32:
#if CPU(ARM64)
jit.multiplyAdd32(args[0].gpr(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::MultiplyAdd64:
#if CPU(ARM64)
jit.multiplyAdd64(args[0].gpr(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::MultiplySub32:
#if CPU(ARM64)
jit.multiplySub32(args[0].gpr(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::MultiplySub64:
#if CPU(ARM64)
jit.multiplySub64(args[0].gpr(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::MultiplyNeg32:
#if CPU(ARM64)
jit.multiplyNeg32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::MultiplyNeg64:
#if CPU(ARM64)
jit.multiplyNeg64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::Div32:
#if CPU(ARM64)
jit.div32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::UDiv32:
#if CPU(ARM64)
jit.uDiv32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::Div64:
#if CPU(ARM64)
jit.div64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::UDiv64:
#if CPU(ARM64)
jit.uDiv64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::MulDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.mulDouble(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.mulDouble(args[0].fpr(), args[1].asAddress(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.mulDouble(args[0].asAddress(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.mulDouble(args[0].asBaseIndex(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.mulDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.mulDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MulFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.mulFloat(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.mulFloat(args[0].fpr(), args[1].asAddress(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.mulFloat(args[0].asAddress(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.mulFloat(args[0].asBaseIndex(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.mulFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.mulFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::DivDouble:
switch (this->args.size()) {
case 3:
#if CPU(ARM64)
jit.divDouble(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.divDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.divDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::DivFloat:
switch (this->args.size()) {
case 3:
#if CPU(ARM64)
jit.divFloat(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.divFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.divFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::X86ConvertToDoubleWord32:
#if CPU(X86) || CPU(X86_64)
jit.x86ConvertToDoubleWord32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::X86ConvertToQuadWord64:
#if CPU(X86_64)
jit.x86ConvertToQuadWord64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::X86Div32:
#if CPU(X86) || CPU(X86_64)
jit.x86Div32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::X86UDiv32:
#if CPU(X86) || CPU(X86_64)
jit.x86UDiv32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::X86Div64:
#if CPU(X86_64)
jit.x86Div64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::X86UDiv64:
#if CPU(X86_64)
jit.x86UDiv64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::Lea32:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.lea32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.x86Lea32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::Lea64:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.lea64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.x86Lea64(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::And32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.and32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.and32(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::BitImm:
#if CPU(ARM64)
jit.and32(args[0].asTrustedImm32(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.and32(args[0].asAddress(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.and32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.and32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.and32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.and32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.and32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.and32(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.and32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.and32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::And64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.and64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
#if USE(JSVALUE64)
case Arg::BitImm64:
#if CPU(ARM64)
jit.and64(args[0].asTrustedImm64(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
#endif // USE(JSVALUE64)
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
jit.and64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.and64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.and64(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
jit.and64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.and64(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.and64(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.and64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.and64(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AndDouble:
switch (this->args.size()) {
case 3:
jit.andDouble(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
case 2:
#if CPU(X86) || CPU(X86_64)
jit.andDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::AndFloat:
switch (this->args.size()) {
case 3:
jit.andFloat(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
case 2:
#if CPU(X86) || CPU(X86_64)
jit.andFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::OrDouble:
switch (this->args.size()) {
case 3:
jit.orDouble(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
case 2:
#if CPU(X86) || CPU(X86_64)
jit.orDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::OrFloat:
switch (this->args.size()) {
case 3:
jit.orFloat(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
case 2:
#if CPU(X86) || CPU(X86_64)
jit.orFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::XorDouble:
switch (this->args.size()) {
case 3:
#if CPU(X86) || CPU(X86_64)
jit.xorDouble(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 2:
#if CPU(X86) || CPU(X86_64)
jit.xorDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::XorFloat:
switch (this->args.size()) {
case 3:
#if CPU(X86) || CPU(X86_64)
jit.xorFloat(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 2:
#if CPU(X86) || CPU(X86_64)
jit.xorFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::Lshift32:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
jit.lshift32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM64)
jit.lshift32(args[0].gpr(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.lshift32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
jit.lshift32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Lshift64:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
jit.lshift64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM64)
jit.lshift64(args[0].gpr(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
jit.lshift64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
jit.lshift64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Rshift32:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
jit.rshift32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM64)
jit.rshift32(args[0].gpr(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.rshift32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
jit.rshift32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Rshift64:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
jit.rshift64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM64)
jit.rshift64(args[0].gpr(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
jit.rshift64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
jit.rshift64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Urshift32:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
jit.urshift32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM64)
jit.urshift32(args[0].gpr(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.urshift32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
jit.urshift32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Urshift64:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
jit.urshift64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM64)
jit.urshift64(args[0].gpr(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
jit.urshift64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
jit.urshift64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::RotateRight32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
jit.rotateRight32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
jit.rotateRight32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
jit.rotateRight32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM64)
jit.rotateRight32(args[0].gpr(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::RotateRight64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
jit.rotateRight64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
jit.rotateRight64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
jit.rotateRight64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM64)
jit.rotateRight64(args[0].gpr(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::RotateLeft32:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
jit.rotateLeft32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
jit.rotateLeft32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::RotateLeft64:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
jit.rotateLeft64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
jit.rotateLeft64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::Or32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.or32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.or32(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::BitImm:
#if CPU(ARM64)
jit.or32(args[0].asTrustedImm32(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.or32(args[0].asAddress(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.or32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.or32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.or32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.or32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.or32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.or32(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.or32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.or32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Or64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.or64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
#if USE(JSVALUE64)
case Arg::BitImm64:
#if CPU(ARM64)
jit.or64(args[0].asTrustedImm64(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
#endif // USE(JSVALUE64)
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.or64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.or64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.or64(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
jit.or64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.or64(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.or64(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.or64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.or64(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Xor32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.xor32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.xor32(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::BitImm:
#if CPU(ARM64)
jit.xor32(args[0].asTrustedImm32(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.xor32(args[0].asAddress(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.xor32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.xor32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.xor32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.xor32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.xor32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.xor32(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.xor32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.xor32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Xor64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.xor64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
#if USE(JSVALUE64)
case Arg::BitImm64:
#if CPU(ARM64)
jit.xor64(args[0].asTrustedImm64(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
#endif // USE(JSVALUE64)
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.xor64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.xor64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.xor64(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.xor64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.xor64(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.xor64(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.xor64(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64)
jit.xor64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Not32:
switch (this->args.size()) {
case 2:
#if CPU(ARM64)
jit.not32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.not32(args[0].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.not32(args[0].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.not32(args[0].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Not64:
switch (this->args.size()) {
case 2:
#if CPU(ARM64)
jit.not64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
jit.not64(args[0].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.not64(args[0].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.not64(args[0].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AbsDouble:
#if CPU(ARM64)
jit.absDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::AbsFloat:
#if CPU(ARM64)
jit.absFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::CeilDouble:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.ceilDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.ceilDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::CeilFloat:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.ceilFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.ceilFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::FloorDouble:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.floorDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.floorDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::FloorFloat:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.floorFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.floorFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::SqrtDouble:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.sqrtDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.sqrtDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::SqrtFloat:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.sqrtFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.sqrtFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::ConvertInt32ToDouble:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.convertInt32ToDouble(args[0].gpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.convertInt32ToDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::ConvertInt64ToDouble:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.convertInt64ToDouble(args[0].gpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.convertInt64ToDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::ConvertInt32ToFloat:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.convertInt32ToFloat(args[0].gpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.convertInt32ToFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::ConvertInt64ToFloat:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.convertInt64ToFloat(args[0].gpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.convertInt64ToFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::CountLeadingZeros32:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.countLeadingZeros32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.countLeadingZeros32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::CountLeadingZeros64:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.countLeadingZeros64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.countLeadingZeros64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::ConvertDoubleToFloat:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.convertDoubleToFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.convertDoubleToFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::ConvertFloatToDouble:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.convertFloatToDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.convertFloatToDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::Move:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.move(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.storePtr(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.storePtr(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.signExtend32ToPtr(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.storePtr(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
#if USE(JSVALUE64)
case Arg::BigImm:
jit.move(args[0].asTrustedImm64(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
#endif // USE(JSVALUE64)
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.loadPtr(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.loadPtr(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::Swap32:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.swap32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.swap32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::Swap64:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
jit.swap64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.swap64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::Move32:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.zeroExtend32ToPtr(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.store32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.store32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.load32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.load32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.zeroExtend32ToPtr(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.store32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.store32(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreZero32:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.storeZero32(args[0].asAddress());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.storeZero32(args[0].asBaseIndex());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::SignExtend32ToPtr:
jit.signExtend32ToPtr(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Opcode::ZeroExtend8To32:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.zeroExtend8To32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.load8(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.load8(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::SignExtend8To32:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.signExtend8To32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.load8SignedExtendTo32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.load8SignedExtendTo32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::ZeroExtend16To32:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.zeroExtend16To32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.load16(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.load16(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::SignExtend16To32:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.signExtend16To32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.load16SignedExtendTo32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.load16SignedExtendTo32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::MoveFloat:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.moveDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.storeFloat(args[0].fpr(), args[1].asAddress());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.storeFloat(args[0].fpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.loadFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.loadFloat(args[0].asBaseIndex(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::MoveDouble:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.moveDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.storeDouble(args[0].fpr(), args[1].asAddress());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.storeDouble(args[0].fpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.loadDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.loadDouble(args[0].asBaseIndex(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::MoveZeroToDouble:
jit.moveZeroToDouble(args[0].fpr());
OPGEN_RETURN(result);
break;
break;
case Opcode::Move64ToDouble:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.move64ToDouble(args[0].gpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.loadDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64) || CPU(ARM64)
jit.loadDouble(args[0].asBaseIndex(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::Move32ToFloat:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.move32ToFloat(args[0].gpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.loadFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
jit.loadFloat(args[0].asBaseIndex(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::MoveDoubleTo64:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.moveDoubleTo64(args[0].fpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64) || CPU(ARM64)
jit.load64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64) || CPU(ARM64)
jit.load64(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::MoveFloatTo32:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.moveFloatTo32(args[0].fpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.load32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.load32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::Load8:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.load8(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.load8(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::LoadAcq8:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.loadAcq8(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.loadAcq8(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::SimpleAddr:
jit.loadAcq8(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::Store8:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Index:
jit.store8(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.store8(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.store8(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.store8(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreRel8:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.storeRel8(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.storeRel8(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::SimpleAddr:
jit.storeRel8(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.storeRel8(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.storeRel8(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Load8SignedExtendTo32:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.load8SignedExtendTo32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.load8SignedExtendTo32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::LoadAcq8SignedExtendTo32:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.loadAcq8SignedExtendTo32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.loadAcq8SignedExtendTo32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::SimpleAddr:
jit.loadAcq8SignedExtendTo32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::Load16:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.load16(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.load16(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::LoadAcq16:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.loadAcq16(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.loadAcq16(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::SimpleAddr:
jit.loadAcq16(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::Load16SignedExtendTo32:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.load16SignedExtendTo32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.load16SignedExtendTo32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::LoadAcq16SignedExtendTo32:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.loadAcq16SignedExtendTo32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.loadAcq16SignedExtendTo32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::SimpleAddr:
jit.loadAcq16SignedExtendTo32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::Store16:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Index:
jit.store16(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.store16(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.store16(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.store16(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreRel16:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.storeRel16(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.storeRel16(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::SimpleAddr:
jit.storeRel16(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.storeRel16(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.storeRel16(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadAcq32:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.loadAcq32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.loadAcq32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::SimpleAddr:
jit.loadAcq32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::StoreRel32:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.storeRel32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.storeRel32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::SimpleAddr:
jit.storeRel32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.storeRel32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.storeRel32(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadAcq64:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.loadAcq64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.loadAcq64(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::SimpleAddr:
#if CPU(X86_64) || CPU(ARM64)
jit.loadAcq64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::StoreRel64:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.storeRel64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.storeRel64(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::SimpleAddr:
#if CPU(X86_64) || CPU(ARM64)
jit.storeRel64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.storeRel64(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.storeRel64(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicStrongCAS8:
switch (this->args.size()) {
case 5:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicStrongCAS8(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asAddress(), args[4].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicStrongCAS8(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asBaseIndex(), args[4].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 3:
switch (this->args[2].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicStrongCAS8(args[0].gpr(), args[1].gpr(), args[2].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicStrongCAS8(args[0].gpr(), args[1].gpr(), args[2].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicStrongCAS16:
switch (this->args.size()) {
case 5:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicStrongCAS16(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asAddress(), args[4].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicStrongCAS16(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asBaseIndex(), args[4].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 3:
switch (this->args[2].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicStrongCAS16(args[0].gpr(), args[1].gpr(), args[2].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicStrongCAS16(args[0].gpr(), args[1].gpr(), args[2].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicStrongCAS32:
switch (this->args.size()) {
case 5:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicStrongCAS32(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asAddress(), args[4].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicStrongCAS32(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asBaseIndex(), args[4].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 3:
switch (this->args[2].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicStrongCAS32(args[0].gpr(), args[1].gpr(), args[2].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicStrongCAS32(args[0].gpr(), args[1].gpr(), args[2].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicStrongCAS64:
switch (this->args.size()) {
case 5:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.atomicStrongCAS64(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asAddress(), args[4].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.atomicStrongCAS64(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asBaseIndex(), args[4].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 3:
switch (this->args[2].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.atomicStrongCAS64(args[0].gpr(), args[1].gpr(), args[2].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.atomicStrongCAS64(args[0].gpr(), args[1].gpr(), args[2].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchAtomicStrongCAS8:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchAtomicStrongCAS8(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
result = jit.branchAtomicStrongCAS8(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::BranchAtomicStrongCAS16:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchAtomicStrongCAS16(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
result = jit.branchAtomicStrongCAS16(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::BranchAtomicStrongCAS32:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchAtomicStrongCAS32(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
result = jit.branchAtomicStrongCAS32(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::BranchAtomicStrongCAS64:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
result = jit.branchAtomicStrongCAS64(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
result = jit.branchAtomicStrongCAS64(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicAdd8:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicAdd8(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicAdd8(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicAdd8(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicAdd8(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAdd16:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicAdd16(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicAdd16(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicAdd16(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicAdd16(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAdd32:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicAdd32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicAdd32(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicAdd32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicAdd32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAdd64:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.atomicAdd64(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.atomicAdd64(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.atomicAdd64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.atomicAdd64(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicSub8:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicSub8(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicSub8(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicSub8(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicSub8(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicSub16:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicSub16(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicSub16(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicSub16(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicSub16(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicSub32:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicSub32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicSub32(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicSub32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicSub32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicSub64:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.atomicSub64(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.atomicSub64(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.atomicSub64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.atomicSub64(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAnd8:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicAnd8(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicAnd8(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicAnd8(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicAnd8(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAnd16:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicAnd16(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicAnd16(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicAnd16(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicAnd16(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAnd32:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicAnd32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicAnd32(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicAnd32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicAnd32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAnd64:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.atomicAnd64(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.atomicAnd64(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.atomicAnd64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.atomicAnd64(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicOr8:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicOr8(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicOr8(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicOr8(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicOr8(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicOr16:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicOr16(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicOr16(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicOr16(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicOr16(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicOr32:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicOr32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicOr32(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicOr32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicOr32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicOr64:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.atomicOr64(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.atomicOr64(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.atomicOr64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.atomicOr64(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXor8:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicXor8(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicXor8(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicXor8(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicXor8(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXor16:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicXor16(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicXor16(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicXor16(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicXor16(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXor32:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicXor32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicXor32(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicXor32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicXor32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXor64:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.atomicXor64(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.atomicXor64(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.atomicXor64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.atomicXor64(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNeg8:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicNeg8(args[0].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicNeg8(args[0].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicNeg16:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicNeg16(args[0].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicNeg16(args[0].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicNeg32:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicNeg32(args[0].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicNeg32(args[0].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicNeg64:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.atomicNeg64(args[0].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.atomicNeg64(args[0].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicNot8:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicNot8(args[0].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicNot8(args[0].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicNot16:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicNot16(args[0].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicNot16(args[0].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicNot32:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicNot32(args[0].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicNot32(args[0].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicNot64:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.atomicNot64(args[0].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.atomicNot64(args[0].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicXchgAdd8:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicXchgAdd8(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicXchgAdd8(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicXchgAdd16:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicXchgAdd16(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicXchgAdd16(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicXchgAdd32:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicXchgAdd32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicXchgAdd32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicXchgAdd64:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.atomicXchgAdd64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.atomicXchgAdd64(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicXchg8:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicXchg8(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicXchg8(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicXchg16:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicXchg16(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicXchg16(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicXchg32:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicXchg32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicXchg32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicXchg64:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.atomicXchg64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.atomicXchg64(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::LoadLink8:
#if CPU(ARM64)
jit.loadLink8(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::LoadLinkAcq8:
#if CPU(ARM64)
jit.loadLinkAcq8(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::StoreCond8:
#if CPU(ARM64)
jit.storeCond8(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::StoreCondRel8:
#if CPU(ARM64)
jit.storeCondRel8(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::LoadLink16:
#if CPU(ARM64)
jit.loadLink16(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::LoadLinkAcq16:
#if CPU(ARM64)
jit.loadLinkAcq16(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::StoreCond16:
#if CPU(ARM64)
jit.storeCond16(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::StoreCondRel16:
#if CPU(ARM64)
jit.storeCondRel16(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::LoadLink32:
#if CPU(ARM64)
jit.loadLink32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::LoadLinkAcq32:
#if CPU(ARM64)
jit.loadLinkAcq32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::StoreCond32:
#if CPU(ARM64)
jit.storeCond32(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::StoreCondRel32:
#if CPU(ARM64)
jit.storeCondRel32(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::LoadLink64:
#if CPU(ARM64)
jit.loadLink64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::LoadLinkAcq64:
#if CPU(ARM64)
jit.loadLinkAcq64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::StoreCond64:
#if CPU(ARM64)
jit.storeCond64(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::StoreCondRel64:
#if CPU(ARM64)
jit.storeCondRel64(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::Depend32:
#if CPU(ARM64)
jit.depend32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::Depend64:
#if CPU(ARM64)
jit.depend64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::Compare32:
switch (this->args[2].kind()) {
case Arg::Tmp:
jit.compare32(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Imm:
jit.compare32(args[0].asRelationalCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::Compare64:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.compare64(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
jit.compare64(args[0].asRelationalCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::Test32:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.test32(args[0].asResultCondition(), args[1].asAddress(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
jit.test32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::BitImm:
jit.test32(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Test64:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86_64)
jit.test64(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.test64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::CompareDouble:
jit.compareDouble(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr(), args[3].gpr());
OPGEN_RETURN(result);
break;
break;
case Opcode::CompareFloat:
jit.compareFloat(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr(), args[3].gpr());
OPGEN_RETURN(result);
break;
break;
case Opcode::Branch8:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branch8(args[0].asRelationalCondition(), args[1].asAddress(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
result = jit.branch8(args[0].asRelationalCondition(), args[1].asBaseIndex(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::Branch32:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
result = jit.branch32(args[0].asRelationalCondition(), args[1].asAddress(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
result = jit.branch32(args[0].asRelationalCondition(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
result = jit.branch32(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Imm:
result = jit.branch32(args[0].asRelationalCondition(), args[1].gpr(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branch32(args[0].asRelationalCondition(), args[1].gpr(), args[2].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
result = jit.branch32(args[0].asRelationalCondition(), args[1].asBaseIndex(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::Branch64:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
result = jit.branch64(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
result = jit.branch64(args[0].asRelationalCondition(), args[1].gpr(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
result = jit.branch64(args[0].asRelationalCondition(), args[1].gpr(), args[2].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
result = jit.branch64(args[0].asRelationalCondition(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
result = jit.branch64(args[0].asRelationalCondition(), args[1].asAddress(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
#if CPU(X86_64)
result = jit.branch64(args[0].asRelationalCondition(), args[1].asBaseIndex(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::BranchTest8:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchTest8(args[0].asResultCondition(), args[1].asAddress(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
result = jit.branchTest8(args[0].asResultCondition(), args[1].asBaseIndex(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::BranchTest32:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
result = jit.branchTest32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::BitImm:
result = jit.branchTest32(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchTest32(args[0].asResultCondition(), args[1].asAddress(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
result = jit.branchTest32(args[0].asResultCondition(), args[1].asBaseIndex(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::BranchTest64:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
result = jit.branchTest64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
#if USE(JSVALUE64)
case Arg::BitImm64:
#if CPU(ARM64)
result = jit.branchTest64(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm64());
OPGEN_RETURN(result);
#endif
break;
break;
#endif // USE(JSVALUE64)
case Arg::BitImm:
#if CPU(X86_64)
result = jit.branchTest64(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::BitImm:
#if CPU(X86_64)
result = jit.branchTest64(args[0].asResultCondition(), args[1].asAddress(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64)
result = jit.branchTest64(args[0].asResultCondition(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
#if CPU(X86_64)
result = jit.branchTest64(args[0].asResultCondition(), args[1].asBaseIndex(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::BranchDouble:
result = jit.branchDouble(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
case Opcode::BranchFloat:
result = jit.branchFloat(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
case Opcode::BranchAdd32:
switch (this->args.size()) {
case 4:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
result = jit.branchAdd32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchAdd32(args[0].asResultCondition(), args[1].gpr(), args[2].asAddress(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchAdd32(args[0].asResultCondition(), args[1].asAddress(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
result = jit.branchAdd32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchAdd32(args[0].asResultCondition(), args[1].gpr(), args[2].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
result = jit.branchAdd32(args[0].asResultCondition(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchAdd32(args[0].asResultCondition(), args[1].asTrustedImm32(), args[2].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchAdd32(args[0].asResultCondition(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchAdd64:
switch (this->args.size()) {
case 4:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
result = jit.branchAdd64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchAdd64(args[0].asResultCondition(), args[1].gpr(), args[2].asAddress(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchAdd64(args[0].asResultCondition(), args[1].asAddress(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 3:
switch (this->args[1].kind()) {
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
result = jit.branchAdd64(args[0].asResultCondition(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
result = jit.branchAdd64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
result = jit.branchAdd64(args[0].asResultCondition(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchMul32:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
result = jit.branchMul32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchMul32(args[0].asResultCondition(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 4:
#if CPU(X86) || CPU(X86_64)
result = jit.branchMul32(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 6:
#if CPU(ARM64)
result = jit.branchMul32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::BranchMul64:
switch (this->args.size()) {
case 3:
#if CPU(X86_64)
result = jit.branchMul64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 6:
#if CPU(ARM64)
result = jit.branchMul64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::BranchSub32:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
result = jit.branchSub32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchSub32(args[0].asResultCondition(), args[1].gpr(), args[2].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
result = jit.branchSub32(args[0].asResultCondition(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchSub32(args[0].asResultCondition(), args[1].asTrustedImm32(), args[2].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchSub32(args[0].asResultCondition(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::BranchSub64:
switch (this->args[1].kind()) {
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
result = jit.branchSub64(args[0].asResultCondition(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
result = jit.branchSub64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::BranchNeg32:
result = jit.branchNeg32(args[0].asResultCondition(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Opcode::BranchNeg64:
#if CPU(X86_64) || CPU(ARM64)
result = jit.branchNeg64(args[0].asResultCondition(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::MoveConditionally32:
switch (this->args.size()) {
case 5:
jit.moveConditionally32(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
break;
break;
case 6:
switch (this->args[2].kind()) {
case Arg::Tmp:
jit.moveConditionally32(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Imm:
jit.moveConditionally32(args[0].asRelationalCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveConditionally64:
switch (this->args.size()) {
case 5:
#if CPU(X86_64) || CPU(ARM64)
jit.moveConditionally64(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 6:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.moveConditionally64(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
jit.moveConditionally64(args[0].asRelationalCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveConditionallyTest32:
switch (this->args.size()) {
case 5:
switch (this->args[2].kind()) {
case Arg::Tmp:
jit.moveConditionallyTest32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
jit.moveConditionallyTest32(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 6:
switch (this->args[2].kind()) {
case Arg::Tmp:
jit.moveConditionallyTest32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::BitImm:
jit.moveConditionallyTest32(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveConditionallyTest64:
switch (this->args.size()) {
case 5:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.moveConditionallyTest64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
jit.moveConditionallyTest64(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 6:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.moveConditionallyTest64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
jit.moveConditionallyTest64(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveConditionallyDouble:
switch (this->args.size()) {
case 6:
jit.moveConditionallyDouble(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
break;
break;
case 5:
jit.moveConditionallyDouble(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::MoveConditionallyFloat:
switch (this->args.size()) {
case 6:
jit.moveConditionallyFloat(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
break;
break;
case 5:
jit.moveConditionallyFloat(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionally32:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
jit.moveDoubleConditionally32(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Imm:
jit.moveDoubleConditionally32(args[0].asRelationalCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.moveDoubleConditionally32(args[0].asRelationalCondition(), args[1].gpr(), args[2].asAddress(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
jit.moveDoubleConditionally32(args[0].asRelationalCondition(), args[1].asAddress(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.moveDoubleConditionally32(args[0].asRelationalCondition(), args[1].asAddress(), args[2].gpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.moveDoubleConditionally32(args[0].asRelationalCondition(), args[1].asBaseIndex(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionally64:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.moveDoubleConditionally64(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
jit.moveDoubleConditionally64(args[0].asRelationalCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.moveDoubleConditionally64(args[0].asRelationalCondition(), args[1].gpr(), args[2].asAddress(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
jit.moveDoubleConditionally64(args[0].asRelationalCondition(), args[1].asAddress(), args[2].gpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
jit.moveDoubleConditionally64(args[0].asRelationalCondition(), args[1].asAddress(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
#if CPU(X86_64)
jit.moveDoubleConditionally64(args[0].asRelationalCondition(), args[1].asBaseIndex(), args[2].gpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionallyTest32:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
jit.moveDoubleConditionallyTest32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::BitImm:
jit.moveDoubleConditionallyTest32(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.moveDoubleConditionallyTest32(args[0].asResultCondition(), args[1].asAddress(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.moveDoubleConditionallyTest32(args[0].asResultCondition(), args[1].asBaseIndex(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionallyTest64:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.moveDoubleConditionallyTest64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
jit.moveDoubleConditionallyTest64(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86_64)
jit.moveDoubleConditionallyTest64(args[0].asResultCondition(), args[1].asAddress(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64)
jit.moveDoubleConditionallyTest64(args[0].asResultCondition(), args[1].asAddress(), args[2].gpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
#if CPU(X86_64)
jit.moveDoubleConditionallyTest64(args[0].asResultCondition(), args[1].asBaseIndex(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionallyDouble:
jit.moveDoubleConditionallyDouble(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
break;
break;
case Opcode::MoveDoubleConditionallyFloat:
jit.moveDoubleConditionallyFloat(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
break;
break;
case Opcode::MemoryFence:
jit.memoryFence();
OPGEN_RETURN(result);
break;
break;
case Opcode::StoreFence:
jit.storeFence();
OPGEN_RETURN(result);
break;
break;
case Opcode::LoadFence:
jit.loadFence();
OPGEN_RETURN(result);
break;
break;
case Opcode::Jump:
result = jit.jump();
OPGEN_RETURN(result);
break;
break;
case Opcode::RetVoid:
jit.retVoid();
OPGEN_RETURN(result);
break;
break;
case Opcode::Ret32:
jit.ret32(args[0].gpr());
OPGEN_RETURN(result);
break;
break;
case Opcode::Ret64:
#if CPU(X86_64) || CPU(ARM64)
jit.ret64(args[0].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::RetFloat:
jit.retFloat(args[0].fpr());
OPGEN_RETURN(result);
break;
break;
case Opcode::RetDouble:
jit.retDouble(args[0].fpr());
OPGEN_RETURN(result);
break;
break;
case Opcode::Oops:
jit.oops();
OPGEN_RETURN(result);
break;
break;
case Opcode::EntrySwitch:
OPGEN_RETURN(EntrySwitchCustom::generate(*this, jit, context));
break;
case Opcode::Shuffle:
OPGEN_RETURN(ShuffleCustom::generate(*this, jit, context));
break;
case Opcode::Patch:
OPGEN_RETURN(PatchCustom::generate(*this, jit, context));
break;
case Opcode::CCall:
OPGEN_RETURN(CCallCustom::generate(*this, jit, context));
break;
case Opcode::ColdCCall:
OPGEN_RETURN(ColdCCallCustom::generate(*this, jit, context));
break;
case Opcode::WasmBoundsCheck:
OPGEN_RETURN(WasmBoundsCheckCustom::generate(*this, jit, context));
break;
default:
break;
}
RELEASE_ASSERT_NOT_REACHED();
return result;
}
} } } // namespace JSC::B3::Air
#endif // AirOpcodeGenerated_h
