"use strict";
// Generated by opcode_generator.rb from /Users/hejian/Downloads/dev_multi_process/Source/JavaScriptCore/b3/air/AirOpcode.opcodes -- do not edit!
const Nop = Symbol("Nop");
const Add32 = Symbol("Add32");
const Add8 = Symbol("Add8");
const Add16 = Symbol("Add16");
const Add64 = Symbol("Add64");
const AddDouble = Symbol("AddDouble");
const AddFloat = Symbol("AddFloat");
const Sub32 = Symbol("Sub32");
const Sub64 = Symbol("Sub64");
const SubDouble = Symbol("SubDouble");
const SubFloat = Symbol("SubFloat");
const Neg32 = Symbol("Neg32");
const Neg64 = Symbol("Neg64");
const NegateDouble = Symbol("NegateDouble");
const NegateFloat = Symbol("NegateFloat");
const Mul32 = Symbol("Mul32");
const Mul64 = Symbol("Mul64");
const MultiplyAdd32 = Symbol("MultiplyAdd32");
const MultiplyAdd64 = Symbol("MultiplyAdd64");
const MultiplySub32 = Symbol("MultiplySub32");
const MultiplySub64 = Symbol("MultiplySub64");
const MultiplyNeg32 = Symbol("MultiplyNeg32");
const MultiplyNeg64 = Symbol("MultiplyNeg64");
const Div32 = Symbol("Div32");
const UDiv32 = Symbol("UDiv32");
const Div64 = Symbol("Div64");
const UDiv64 = Symbol("UDiv64");
const MulDouble = Symbol("MulDouble");
const MulFloat = Symbol("MulFloat");
const DivDouble = Symbol("DivDouble");
const DivFloat = Symbol("DivFloat");
const X86ConvertToDoubleWord32 = Symbol("X86ConvertToDoubleWord32");
const X86ConvertToQuadWord64 = Symbol("X86ConvertToQuadWord64");
const X86Div32 = Symbol("X86Div32");
const X86UDiv32 = Symbol("X86UDiv32");
const X86Div64 = Symbol("X86Div64");
const X86UDiv64 = Symbol("X86UDiv64");
const Lea32 = Symbol("Lea32");
const Lea64 = Symbol("Lea64");
const And32 = Symbol("And32");
const And64 = Symbol("And64");
const AndDouble = Symbol("AndDouble");
const AndFloat = Symbol("AndFloat");
const OrDouble = Symbol("OrDouble");
const OrFloat = Symbol("OrFloat");
const XorDouble = Symbol("XorDouble");
const XorFloat = Symbol("XorFloat");
const Lshift32 = Symbol("Lshift32");
const Lshift64 = Symbol("Lshift64");
const Rshift32 = Symbol("Rshift32");
const Rshift64 = Symbol("Rshift64");
const Urshift32 = Symbol("Urshift32");
const Urshift64 = Symbol("Urshift64");
const RotateRight32 = Symbol("RotateRight32");
const RotateRight64 = Symbol("RotateRight64");
const RotateLeft32 = Symbol("RotateLeft32");
const RotateLeft64 = Symbol("RotateLeft64");
const Or32 = Symbol("Or32");
const Or64 = Symbol("Or64");
const Xor32 = Symbol("Xor32");
const Xor64 = Symbol("Xor64");
const Not32 = Symbol("Not32");
const Not64 = Symbol("Not64");
const AbsDouble = Symbol("AbsDouble");
const AbsFloat = Symbol("AbsFloat");
const CeilDouble = Symbol("CeilDouble");
const CeilFloat = Symbol("CeilFloat");
const FloorDouble = Symbol("FloorDouble");
const FloorFloat = Symbol("FloorFloat");
const SqrtDouble = Symbol("SqrtDouble");
const SqrtFloat = Symbol("SqrtFloat");
const ConvertInt32ToDouble = Symbol("ConvertInt32ToDouble");
const ConvertInt64ToDouble = Symbol("ConvertInt64ToDouble");
const ConvertInt32ToFloat = Symbol("ConvertInt32ToFloat");
const ConvertInt64ToFloat = Symbol("ConvertInt64ToFloat");
const CountLeadingZeros32 = Symbol("CountLeadingZeros32");
const CountLeadingZeros64 = Symbol("CountLeadingZeros64");
const ConvertDoubleToFloat = Symbol("ConvertDoubleToFloat");
const ConvertFloatToDouble = Symbol("ConvertFloatToDouble");
const Move = Symbol("Move");
const Swap32 = Symbol("Swap32");
const Swap64 = Symbol("Swap64");
const Move32 = Symbol("Move32");
const StoreZero32 = Symbol("StoreZero32");
const SignExtend32ToPtr = Symbol("SignExtend32ToPtr");
const ZeroExtend8To32 = Symbol("ZeroExtend8To32");
const SignExtend8To32 = Symbol("SignExtend8To32");
const ZeroExtend16To32 = Symbol("ZeroExtend16To32");
const SignExtend16To32 = Symbol("SignExtend16To32");
const MoveFloat = Symbol("MoveFloat");
const MoveDouble = Symbol("MoveDouble");
const MoveZeroToDouble = Symbol("MoveZeroToDouble");
const Move64ToDouble = Symbol("Move64ToDouble");
const Move32ToFloat = Symbol("Move32ToFloat");
const MoveDoubleTo64 = Symbol("MoveDoubleTo64");
const MoveFloatTo32 = Symbol("MoveFloatTo32");
const Load8 = Symbol("Load8");
const LoadAcq8 = Symbol("LoadAcq8");
const Store8 = Symbol("Store8");
const StoreRel8 = Symbol("StoreRel8");
const Load8SignedExtendTo32 = Symbol("Load8SignedExtendTo32");
const LoadAcq8SignedExtendTo32 = Symbol("LoadAcq8SignedExtendTo32");
const Load16 = Symbol("Load16");
const LoadAcq16 = Symbol("LoadAcq16");
const Load16SignedExtendTo32 = Symbol("Load16SignedExtendTo32");
const LoadAcq16SignedExtendTo32 = Symbol("LoadAcq16SignedExtendTo32");
const Store16 = Symbol("Store16");
const StoreRel16 = Symbol("StoreRel16");
const LoadAcq32 = Symbol("LoadAcq32");
const StoreRel32 = Symbol("StoreRel32");
const LoadAcq64 = Symbol("LoadAcq64");
const StoreRel64 = Symbol("StoreRel64");
const AtomicStrongCAS8 = Symbol("AtomicStrongCAS8");
const AtomicStrongCAS16 = Symbol("AtomicStrongCAS16");
const AtomicStrongCAS32 = Symbol("AtomicStrongCAS32");
const AtomicStrongCAS64 = Symbol("AtomicStrongCAS64");
const BranchAtomicStrongCAS8 = Symbol("BranchAtomicStrongCAS8");
const BranchAtomicStrongCAS16 = Symbol("BranchAtomicStrongCAS16");
const BranchAtomicStrongCAS32 = Symbol("BranchAtomicStrongCAS32");
const BranchAtomicStrongCAS64 = Symbol("BranchAtomicStrongCAS64");
const AtomicAdd8 = Symbol("AtomicAdd8");
const AtomicAdd16 = Symbol("AtomicAdd16");
const AtomicAdd32 = Symbol("AtomicAdd32");
const AtomicAdd64 = Symbol("AtomicAdd64");
const AtomicSub8 = Symbol("AtomicSub8");
const AtomicSub16 = Symbol("AtomicSub16");
const AtomicSub32 = Symbol("AtomicSub32");
const AtomicSub64 = Symbol("AtomicSub64");
const AtomicAnd8 = Symbol("AtomicAnd8");
const AtomicAnd16 = Symbol("AtomicAnd16");
const AtomicAnd32 = Symbol("AtomicAnd32");
const AtomicAnd64 = Symbol("AtomicAnd64");
const AtomicOr8 = Symbol("AtomicOr8");
const AtomicOr16 = Symbol("AtomicOr16");
const AtomicOr32 = Symbol("AtomicOr32");
const AtomicOr64 = Symbol("AtomicOr64");
const AtomicXor8 = Symbol("AtomicXor8");
const AtomicXor16 = Symbol("AtomicXor16");
const AtomicXor32 = Symbol("AtomicXor32");
const AtomicXor64 = Symbol("AtomicXor64");
const AtomicNeg8 = Symbol("AtomicNeg8");
const AtomicNeg16 = Symbol("AtomicNeg16");
const AtomicNeg32 = Symbol("AtomicNeg32");
const AtomicNeg64 = Symbol("AtomicNeg64");
const AtomicNot8 = Symbol("AtomicNot8");
const AtomicNot16 = Symbol("AtomicNot16");
const AtomicNot32 = Symbol("AtomicNot32");
const AtomicNot64 = Symbol("AtomicNot64");
const AtomicXchgAdd8 = Symbol("AtomicXchgAdd8");
const AtomicXchgAdd16 = Symbol("AtomicXchgAdd16");
const AtomicXchgAdd32 = Symbol("AtomicXchgAdd32");
const AtomicXchgAdd64 = Symbol("AtomicXchgAdd64");
const AtomicXchg8 = Symbol("AtomicXchg8");
const AtomicXchg16 = Symbol("AtomicXchg16");
const AtomicXchg32 = Symbol("AtomicXchg32");
const AtomicXchg64 = Symbol("AtomicXchg64");
const LoadLink8 = Symbol("LoadLink8");
const LoadLinkAcq8 = Symbol("LoadLinkAcq8");
const StoreCond8 = Symbol("StoreCond8");
const StoreCondRel8 = Symbol("StoreCondRel8");
const LoadLink16 = Symbol("LoadLink16");
const LoadLinkAcq16 = Symbol("LoadLinkAcq16");
const StoreCond16 = Symbol("StoreCond16");
const StoreCondRel16 = Symbol("StoreCondRel16");
const LoadLink32 = Symbol("LoadLink32");
const LoadLinkAcq32 = Symbol("LoadLinkAcq32");
const StoreCond32 = Symbol("StoreCond32");
const StoreCondRel32 = Symbol("StoreCondRel32");
const LoadLink64 = Symbol("LoadLink64");
const LoadLinkAcq64 = Symbol("LoadLinkAcq64");
const StoreCond64 = Symbol("StoreCond64");
const StoreCondRel64 = Symbol("StoreCondRel64");
const Depend32 = Symbol("Depend32");
const Depend64 = Symbol("Depend64");
const Compare32 = Symbol("Compare32");
const Compare64 = Symbol("Compare64");
const Test32 = Symbol("Test32");
const Test64 = Symbol("Test64");
const CompareDouble = Symbol("CompareDouble");
const CompareFloat = Symbol("CompareFloat");
const Branch8 = Symbol("Branch8");
const Branch32 = Symbol("Branch32");
const Branch64 = Symbol("Branch64");
const BranchTest8 = Symbol("BranchTest8");
const BranchTest32 = Symbol("BranchTest32");
const BranchTest64 = Symbol("BranchTest64");
const BranchDouble = Symbol("BranchDouble");
const BranchFloat = Symbol("BranchFloat");
const BranchAdd32 = Symbol("BranchAdd32");
const BranchAdd64 = Symbol("BranchAdd64");
const BranchMul32 = Symbol("BranchMul32");
const BranchMul64 = Symbol("BranchMul64");
const BranchSub32 = Symbol("BranchSub32");
const BranchSub64 = Symbol("BranchSub64");
const BranchNeg32 = Symbol("BranchNeg32");
const BranchNeg64 = Symbol("BranchNeg64");
const MoveConditionally32 = Symbol("MoveConditionally32");
const MoveConditionally64 = Symbol("MoveConditionally64");
const MoveConditionallyTest32 = Symbol("MoveConditionallyTest32");
const MoveConditionallyTest64 = Symbol("MoveConditionallyTest64");
const MoveConditionallyDouble = Symbol("MoveConditionallyDouble");
const MoveConditionallyFloat = Symbol("MoveConditionallyFloat");
const MoveDoubleConditionally32 = Symbol("MoveDoubleConditionally32");
const MoveDoubleConditionally64 = Symbol("MoveDoubleConditionally64");
const MoveDoubleConditionallyTest32 = Symbol("MoveDoubleConditionallyTest32");
const MoveDoubleConditionallyTest64 = Symbol("MoveDoubleConditionallyTest64");
const MoveDoubleConditionallyDouble = Symbol("MoveDoubleConditionallyDouble");
const MoveDoubleConditionallyFloat = Symbol("MoveDoubleConditionallyFloat");
const MemoryFence = Symbol("MemoryFence");
const StoreFence = Symbol("StoreFence");
const LoadFence = Symbol("LoadFence");
const Jump = Symbol("Jump");
const RetVoid = Symbol("RetVoid");
const Ret32 = Symbol("Ret32");
const Ret64 = Symbol("Ret64");
const RetFloat = Symbol("RetFloat");
const RetDouble = Symbol("RetDouble");
const Oops = Symbol("Oops");
const EntrySwitch = Symbol("EntrySwitch");
const Shuffle = Symbol("Shuffle");
const Patch = Symbol("Patch");
const CCall = Symbol("CCall");
const ColdCCall = Symbol("ColdCCall");
const WasmBoundsCheck = Symbol("WasmBoundsCheck");
function Inst_forEachArg(inst, func)
{
let replacement;
switch (inst.opcode) {
case Opcode::Nop:
break;
break;
case Opcode::Add32:
switch (inst.args.length) {
case 3:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 32);
inst.visitArg(2, func, Arg.ZDef, GP, 32);
break;
case 2:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.UseZDef, GP, 32);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::Add8:
inst.visitArg(0, func, Arg.Use, GP, 8);
inst.visitArg(1, func, Arg.UseDef, GP, 8);
break;
break;
case Opcode::Add16:
inst.visitArg(0, func, Arg.Use, GP, 16);
inst.visitArg(1, func, Arg.UseDef, GP, 16);
break;
break;
case Opcode::Add64:
switch (inst.args.length) {
case 2:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.UseDef, GP, 64);
break;
case 3:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.Use, GP, 64);
inst.visitArg(2, func, Arg.Def, GP, 64);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::AddDouble:
switch (inst.args.length) {
case 3:
inst.visitArg(0, func, Arg.Use, FP, 64);
inst.visitArg(1, func, Arg.Use, FP, 64);
inst.visitArg(2, func, Arg.Def, FP, 64);
break;
case 2:
inst.visitArg(0, func, Arg.Use, FP, 64);
inst.visitArg(1, func, Arg.UseDef, FP, 64);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::AddFloat:
switch (inst.args.length) {
case 3:
inst.visitArg(0, func, Arg.Use, FP, 32);
inst.visitArg(1, func, Arg.Use, FP, 32);
inst.visitArg(2, func, Arg.Def, FP, 32);
break;
case 2:
inst.visitArg(0, func, Arg.Use, FP, 32);
inst.visitArg(1, func, Arg.UseDef, FP, 32);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::Sub32:
switch (inst.args.length) {
case 2:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.UseZDef, GP, 32);
break;
case 3:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 32);
inst.visitArg(2, func, Arg.Def, GP, 32);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::Sub64:
switch (inst.args.length) {
case 2:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.UseDef, GP, 64);
break;
case 3:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.Use, GP, 64);
inst.visitArg(2, func, Arg.Def, GP, 64);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::SubDouble:
switch (inst.args.length) {
case 3:
inst.visitArg(0, func, Arg.Use, FP, 64);
inst.visitArg(1, func, Arg.Use, FP, 64);
inst.visitArg(2, func, Arg.Def, FP, 64);
break;
case 2:
inst.visitArg(0, func, Arg.Use, FP, 64);
inst.visitArg(1, func, Arg.UseDef, FP, 64);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::SubFloat:
switch (inst.args.length) {
case 3:
inst.visitArg(0, func, Arg.Use, FP, 32);
inst.visitArg(1, func, Arg.Use, FP, 32);
inst.visitArg(2, func, Arg.Def, FP, 32);
break;
case 2:
inst.visitArg(0, func, Arg.Use, FP, 32);
inst.visitArg(1, func, Arg.UseDef, FP, 32);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::Neg32:
inst.visitArg(0, func, Arg.UseZDef, GP, 32);
break;
break;
case Opcode::Neg64:
inst.visitArg(0, func, Arg.UseDef, GP, 64);
break;
break;
case Opcode::NegateDouble:
inst.visitArg(0, func, Arg.Use, FP, 64);
inst.visitArg(1, func, Arg.Def, FP, 64);
break;
break;
case Opcode::NegateFloat:
inst.visitArg(0, func, Arg.Use, FP, 32);
inst.visitArg(1, func, Arg.Def, FP, 32);
break;
break;
case Opcode::Mul32:
switch (inst.args.length) {
case 2:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.UseZDef, GP, 32);
break;
case 3:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 32);
inst.visitArg(2, func, Arg.ZDef, GP, 32);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::Mul64:
switch (inst.args.length) {
case 2:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.UseDef, GP, 64);
break;
case 3:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.Use, GP, 64);
inst.visitArg(2, func, Arg.Def, GP, 64);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::MultiplyAdd32:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 32);
inst.visitArg(2, func, Arg.Use, GP, 32);
inst.visitArg(3, func, Arg.ZDef, GP, 32);
break;
break;
case Opcode::MultiplyAdd64:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.Use, GP, 64);
inst.visitArg(2, func, Arg.Use, GP, 64);
inst.visitArg(3, func, Arg.Def, GP, 64);
break;
break;
case Opcode::MultiplySub32:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 32);
inst.visitArg(2, func, Arg.Use, GP, 32);
inst.visitArg(3, func, Arg.ZDef, GP, 32);
break;
break;
case Opcode::MultiplySub64:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.Use, GP, 64);
inst.visitArg(2, func, Arg.Use, GP, 64);
inst.visitArg(3, func, Arg.Def, GP, 64);
break;
break;
case Opcode::MultiplyNeg32:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 32);
inst.visitArg(2, func, Arg.ZDef, GP, 32);
break;
break;
case Opcode::MultiplyNeg64:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.Use, GP, 64);
inst.visitArg(2, func, Arg.ZDef, GP, 64);
break;
break;
case Opcode::Div32:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 32);
inst.visitArg(2, func, Arg.ZDef, GP, 32);
break;
break;
case Opcode::UDiv32:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 32);
inst.visitArg(2, func, Arg.ZDef, GP, 32);
break;
break;
case Opcode::Div64:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.Use, GP, 64);
inst.visitArg(2, func, Arg.Def, GP, 64);
break;
break;
case Opcode::UDiv64:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.Use, GP, 64);
inst.visitArg(2, func, Arg.Def, GP, 64);
break;
break;
case Opcode::MulDouble:
switch (inst.args.length) {
case 3:
inst.visitArg(0, func, Arg.Use, FP, 64);
inst.visitArg(1, func, Arg.Use, FP, 64);
inst.visitArg(2, func, Arg.Def, FP, 64);
break;
case 2:
inst.visitArg(0, func, Arg.Use, FP, 64);
inst.visitArg(1, func, Arg.UseDef, FP, 64);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::MulFloat:
switch (inst.args.length) {
case 3:
inst.visitArg(0, func, Arg.Use, FP, 32);
inst.visitArg(1, func, Arg.Use, FP, 32);
inst.visitArg(2, func, Arg.Def, FP, 32);
break;
case 2:
inst.visitArg(0, func, Arg.Use, FP, 32);
inst.visitArg(1, func, Arg.UseDef, FP, 32);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::DivDouble:
switch (inst.args.length) {
case 3:
inst.visitArg(0, func, Arg.Use, FP, 64);
inst.visitArg(1, func, Arg.Use, FP, 32);
inst.visitArg(2, func, Arg.Def, FP, 64);
break;
case 2:
inst.visitArg(0, func, Arg.Use, FP, 64);
inst.visitArg(1, func, Arg.UseDef, FP, 64);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::DivFloat:
switch (inst.args.length) {
case 3:
inst.visitArg(0, func, Arg.Use, FP, 32);
inst.visitArg(1, func, Arg.Use, FP, 32);
inst.visitArg(2, func, Arg.Def, FP, 32);
break;
case 2:
inst.visitArg(0, func, Arg.Use, FP, 32);
inst.visitArg(1, func, Arg.UseDef, FP, 32);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::X86ConvertToDoubleWord32:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.ZDef, GP, 32);
break;
break;
case Opcode::X86ConvertToQuadWord64:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.Def, GP, 64);
break;
break;
case Opcode::X86Div32:
inst.visitArg(0, func, Arg.UseZDef, GP, 32);
inst.visitArg(1, func, Arg.UseZDef, GP, 32);
inst.visitArg(2, func, Arg.Use, GP, 32);
break;
break;
case Opcode::X86UDiv32:
inst.visitArg(0, func, Arg.UseZDef, GP, 32);
inst.visitArg(1, func, Arg.UseZDef, GP, 32);
inst.visitArg(2, func, Arg.Use, GP, 32);
break;
break;
case Opcode::X86Div64:
inst.visitArg(0, func, Arg.UseZDef, GP, 64);
inst.visitArg(1, func, Arg.UseZDef, GP, 64);
inst.visitArg(2, func, Arg.Use, GP, 64);
break;
break;
case Opcode::X86UDiv64:
inst.visitArg(0, func, Arg.UseZDef, GP, 64);
inst.visitArg(1, func, Arg.UseZDef, GP, 64);
inst.visitArg(2, func, Arg.Use, GP, 64);
break;
break;
case Opcode::Lea32:
inst.visitArg(0, func, Arg.UseAddr, GP, 32);
inst.visitArg(1, func, Arg.Def, GP, 32);
break;
break;
case Opcode::Lea64:
inst.visitArg(0, func, Arg.UseAddr, GP, 64);
inst.visitArg(1, func, Arg.Def, GP, 64);
break;
break;
case Opcode::And32:
switch (inst.args.length) {
case 3:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 32);
inst.visitArg(2, func, Arg.ZDef, GP, 32);
break;
case 2:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.UseZDef, GP, 32);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::And64:
switch (inst.args.length) {
case 3:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.Use, GP, 64);
inst.visitArg(2, func, Arg.Def, GP, 64);
break;
case 2:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.UseDef, GP, 64);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::AndDouble:
switch (inst.args.length) {
case 3:
inst.visitArg(0, func, Arg.Use, FP, 64);
inst.visitArg(1, func, Arg.Use, FP, 64);
inst.visitArg(2, func, Arg.Def, FP, 64);
break;
case 2:
inst.visitArg(0, func, Arg.Use, FP, 64);
inst.visitArg(1, func, Arg.UseDef, FP, 64);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::AndFloat:
switch (inst.args.length) {
case 3:
inst.visitArg(0, func, Arg.Use, FP, 32);
inst.visitArg(1, func, Arg.Use, FP, 32);
inst.visitArg(2, func, Arg.Def, FP, 32);
break;
case 2:
inst.visitArg(0, func, Arg.Use, FP, 32);
inst.visitArg(1, func, Arg.UseDef, FP, 32);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::OrDouble:
switch (inst.args.length) {
case 3:
inst.visitArg(0, func, Arg.Use, FP, 64);
inst.visitArg(1, func, Arg.Use, FP, 64);
inst.visitArg(2, func, Arg.Def, FP, 64);
break;
case 2:
inst.visitArg(0, func, Arg.Use, FP, 64);
inst.visitArg(1, func, Arg.UseDef, FP, 64);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::OrFloat:
switch (inst.args.length) {
case 3:
inst.visitArg(0, func, Arg.Use, FP, 32);
inst.visitArg(1, func, Arg.Use, FP, 32);
inst.visitArg(2, func, Arg.Def, FP, 32);
break;
case 2:
inst.visitArg(0, func, Arg.Use, FP, 32);
inst.visitArg(1, func, Arg.UseDef, FP, 32);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::XorDouble:
switch (inst.args.length) {
case 3:
inst.visitArg(0, func, Arg.Use, FP, 64);
inst.visitArg(1, func, Arg.Use, FP, 64);
inst.visitArg(2, func, Arg.Def, FP, 64);
break;
case 2:
inst.visitArg(0, func, Arg.Use, FP, 64);
inst.visitArg(1, func, Arg.UseDef, FP, 64);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::XorFloat:
switch (inst.args.length) {
case 3:
inst.visitArg(0, func, Arg.Use, FP, 32);
inst.visitArg(1, func, Arg.Use, FP, 32);
inst.visitArg(2, func, Arg.Def, FP, 32);
break;
case 2:
inst.visitArg(0, func, Arg.Use, FP, 32);
inst.visitArg(1, func, Arg.UseDef, FP, 32);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::Lshift32:
switch (inst.args.length) {
case 3:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 32);
inst.visitArg(2, func, Arg.ZDef, GP, 32);
break;
case 2:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.UseZDef, GP, 32);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::Lshift64:
switch (inst.args.length) {
case 3:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.Use, GP, 64);
inst.visitArg(2, func, Arg.Def, GP, 64);
break;
case 2:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.UseDef, GP, 64);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::Rshift32:
switch (inst.args.length) {
case 3:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 32);
inst.visitArg(2, func, Arg.ZDef, GP, 32);
break;
case 2:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.UseZDef, GP, 32);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::Rshift64:
switch (inst.args.length) {
case 3:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.Use, GP, 64);
inst.visitArg(2, func, Arg.Def, GP, 64);
break;
case 2:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.UseDef, GP, 64);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::Urshift32:
switch (inst.args.length) {
case 3:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 32);
inst.visitArg(2, func, Arg.ZDef, GP, 32);
break;
case 2:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.UseZDef, GP, 32);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::Urshift64:
switch (inst.args.length) {
case 3:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.Use, GP, 64);
inst.visitArg(2, func, Arg.Def, GP, 64);
break;
case 2:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.UseDef, GP, 64);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::RotateRight32:
switch (inst.args.length) {
case 2:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.UseZDef, GP, 32);
break;
case 3:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 32);
inst.visitArg(2, func, Arg.ZDef, GP, 32);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::RotateRight64:
switch (inst.args.length) {
case 2:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.UseDef, GP, 64);
break;
case 3:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.Use, GP, 64);
inst.visitArg(2, func, Arg.Def, GP, 64);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::RotateLeft32:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.UseZDef, GP, 32);
break;
break;
case Opcode::RotateLeft64:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.UseDef, GP, 64);
break;
break;
case Opcode::Or32:
switch (inst.args.length) {
case 3:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 32);
inst.visitArg(2, func, Arg.ZDef, GP, 32);
break;
case 2:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.UseZDef, GP, 32);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::Or64:
switch (inst.args.length) {
case 3:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.Use, GP, 64);
inst.visitArg(2, func, Arg.Def, GP, 64);
break;
case 2:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.UseDef, GP, 64);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::Xor32:
switch (inst.args.length) {
case 3:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 32);
inst.visitArg(2, func, Arg.ZDef, GP, 32);
break;
case 2:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.UseZDef, GP, 32);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::Xor64:
switch (inst.args.length) {
case 3:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.Use, GP, 64);
inst.visitArg(2, func, Arg.Def, GP, 64);
break;
case 2:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.UseDef, GP, 64);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::Not32:
switch (inst.args.length) {
case 2:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.ZDef, GP, 32);
break;
case 1:
inst.visitArg(0, func, Arg.UseZDef, GP, 32);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::Not64:
switch (inst.args.length) {
case 2:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.Def, GP, 64);
break;
case 1:
inst.visitArg(0, func, Arg.UseDef, GP, 64);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::AbsDouble:
inst.visitArg(0, func, Arg.Use, FP, 64);
inst.visitArg(1, func, Arg.Def, FP, 64);
break;
break;
case Opcode::AbsFloat:
inst.visitArg(0, func, Arg.Use, FP, 32);
inst.visitArg(1, func, Arg.Def, FP, 32);
break;
break;
case Opcode::CeilDouble:
inst.visitArg(0, func, Arg.Use, FP, 64);
inst.visitArg(1, func, Arg.Def, FP, 64);
break;
break;
case Opcode::CeilFloat:
inst.visitArg(0, func, Arg.Use, FP, 32);
inst.visitArg(1, func, Arg.Def, FP, 32);
break;
break;
case Opcode::FloorDouble:
inst.visitArg(0, func, Arg.Use, FP, 64);
inst.visitArg(1, func, Arg.Def, FP, 64);
break;
break;
case Opcode::FloorFloat:
inst.visitArg(0, func, Arg.Use, FP, 32);
inst.visitArg(1, func, Arg.Def, FP, 32);
break;
break;
case Opcode::SqrtDouble:
inst.visitArg(0, func, Arg.Use, FP, 64);
inst.visitArg(1, func, Arg.Def, FP, 64);
break;
break;
case Opcode::SqrtFloat:
inst.visitArg(0, func, Arg.Use, FP, 32);
inst.visitArg(1, func, Arg.Def, FP, 32);
break;
break;
case Opcode::ConvertInt32ToDouble:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Def, FP, 64);
break;
break;
case Opcode::ConvertInt64ToDouble:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.Def, FP, 64);
break;
break;
case Opcode::ConvertInt32ToFloat:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Def, FP, 32);
break;
break;
case Opcode::ConvertInt64ToFloat:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.Def, FP, 32);
break;
break;
case Opcode::CountLeadingZeros32:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.ZDef, GP, 32);
break;
break;
case Opcode::CountLeadingZeros64:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.Def, GP, 64);
break;
break;
case Opcode::ConvertDoubleToFloat:
inst.visitArg(0, func, Arg.Use, FP, 64);
inst.visitArg(1, func, Arg.Def, FP, 32);
break;
break;
case Opcode::ConvertFloatToDouble:
inst.visitArg(0, func, Arg.Use, FP, 32);
inst.visitArg(1, func, Arg.Def, FP, 64);
break;
break;
case Opcode::Move:
inst.visitArg(0, func, Arg.Use, GP, Ptr);
inst.visitArg(1, func, Arg.Def, GP, Ptr);
break;
break;
case Opcode::Swap32:
inst.visitArg(0, func, Arg.UseDef, GP, 32);
inst.visitArg(1, func, Arg.UseDef, GP, 32);
break;
break;
case Opcode::Swap64:
inst.visitArg(0, func, Arg.UseDef, GP, 64);
inst.visitArg(1, func, Arg.UseDef, GP, 64);
break;
break;
case Opcode::Move32:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.ZDef, GP, 32);
break;
break;
case Opcode::StoreZero32:
inst.visitArg(0, func, Arg.Use, GP, 32);
break;
break;
case Opcode::SignExtend32ToPtr:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Def, GP, Ptr);
break;
break;
case Opcode::ZeroExtend8To32:
inst.visitArg(0, func, Arg.Use, GP, 8);
inst.visitArg(1, func, Arg.ZDef, GP, 32);
break;
break;
case Opcode::SignExtend8To32:
inst.visitArg(0, func, Arg.Use, GP, 8);
inst.visitArg(1, func, Arg.ZDef, GP, 32);
break;
break;
case Opcode::ZeroExtend16To32:
inst.visitArg(0, func, Arg.Use, GP, 16);
inst.visitArg(1, func, Arg.ZDef, GP, 32);
break;
break;
case Opcode::SignExtend16To32:
inst.visitArg(0, func, Arg.Use, GP, 16);
inst.visitArg(1, func, Arg.ZDef, GP, 32);
break;
break;
case Opcode::MoveFloat:
inst.visitArg(0, func, Arg.Use, FP, 32);
inst.visitArg(1, func, Arg.Def, FP, 32);
break;
break;
case Opcode::MoveDouble:
inst.visitArg(0, func, Arg.Use, FP, 64);
inst.visitArg(1, func, Arg.Def, FP, 64);
break;
break;
case Opcode::MoveZeroToDouble:
inst.visitArg(0, func, Arg.Def, FP, 64);
break;
break;
case Opcode::Move64ToDouble:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.Def, FP, 64);
break;
break;
case Opcode::Move32ToFloat:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Def, FP, 32);
break;
break;
case Opcode::MoveDoubleTo64:
inst.visitArg(0, func, Arg.Use, FP, 64);
inst.visitArg(1, func, Arg.Def, GP, 64);
break;
break;
case Opcode::MoveFloatTo32:
inst.visitArg(0, func, Arg.Use, FP, 32);
inst.visitArg(1, func, Arg.Def, GP, 32);
break;
break;
case Opcode::Load8:
inst.visitArg(0, func, Arg.Use, GP, 8);
inst.visitArg(1, func, Arg.ZDef, GP, 32);
break;
break;
case Opcode::LoadAcq8:
inst.visitArg(0, func, Arg.Use, GP, 8);
inst.visitArg(1, func, Arg.ZDef, GP, 32);
break;
break;
case Opcode::Store8:
inst.visitArg(0, func, Arg.Use, GP, 8);
inst.visitArg(1, func, Arg.Def, GP, 8);
break;
break;
case Opcode::StoreRel8:
inst.visitArg(0, func, Arg.Use, GP, 8);
inst.visitArg(1, func, Arg.Def, GP, 8);
break;
break;
case Opcode::Load8SignedExtendTo32:
inst.visitArg(0, func, Arg.Use, GP, 8);
inst.visitArg(1, func, Arg.ZDef, GP, 32);
break;
break;
case Opcode::LoadAcq8SignedExtendTo32:
inst.visitArg(0, func, Arg.Use, GP, 8);
inst.visitArg(1, func, Arg.ZDef, GP, 32);
break;
break;
case Opcode::Load16:
inst.visitArg(0, func, Arg.Use, GP, 16);
inst.visitArg(1, func, Arg.ZDef, GP, 32);
break;
break;
case Opcode::LoadAcq16:
inst.visitArg(0, func, Arg.Use, GP, 16);
inst.visitArg(1, func, Arg.ZDef, GP, 32);
break;
break;
case Opcode::Load16SignedExtendTo32:
inst.visitArg(0, func, Arg.Use, GP, 16);
inst.visitArg(1, func, Arg.ZDef, GP, 32);
break;
break;
case Opcode::LoadAcq16SignedExtendTo32:
inst.visitArg(0, func, Arg.Use, GP, 16);
inst.visitArg(1, func, Arg.ZDef, GP, 32);
break;
break;
case Opcode::Store16:
inst.visitArg(0, func, Arg.Use, GP, 16);
inst.visitArg(1, func, Arg.Def, GP, 16);
break;
break;
case Opcode::StoreRel16:
inst.visitArg(0, func, Arg.Use, GP, 16);
inst.visitArg(1, func, Arg.Def, GP, 16);
break;
break;
case Opcode::LoadAcq32:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.ZDef, GP, 32);
break;
break;
case Opcode::StoreRel32:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.ZDef, GP, 32);
break;
break;
case Opcode::LoadAcq64:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.ZDef, GP, 64);
break;
break;
case Opcode::StoreRel64:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.ZDef, GP, 64);
break;
break;
case Opcode::AtomicStrongCAS8:
switch (inst.args.length) {
case 5:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.UseDef, GP, 8);
inst.visitArg(2, func, Arg.Use, GP, 8);
inst.visitArg(3, func, Arg.UseDef, GP, 8);
inst.visitArg(4, func, Arg.ZDef, GP, 8);
break;
case 3:
inst.visitArg(0, func, Arg.UseDef, GP, 8);
inst.visitArg(1, func, Arg.Use, GP, 8);
inst.visitArg(2, func, Arg.UseDef, GP, 8);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::AtomicStrongCAS16:
switch (inst.args.length) {
case 5:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.UseDef, GP, 16);
inst.visitArg(2, func, Arg.Use, GP, 32);
inst.visitArg(3, func, Arg.UseDef, GP, 16);
inst.visitArg(4, func, Arg.ZDef, GP, 8);
break;
case 3:
inst.visitArg(0, func, Arg.UseDef, GP, 16);
inst.visitArg(1, func, Arg.Use, GP, 32);
inst.visitArg(2, func, Arg.UseDef, GP, 16);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::AtomicStrongCAS32:
switch (inst.args.length) {
case 5:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.UseDef, GP, 32);
inst.visitArg(2, func, Arg.Use, GP, 32);
inst.visitArg(3, func, Arg.UseDef, GP, 32);
inst.visitArg(4, func, Arg.ZDef, GP, 8);
break;
case 3:
inst.visitArg(0, func, Arg.UseDef, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 32);
inst.visitArg(2, func, Arg.UseDef, GP, 32);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::AtomicStrongCAS64:
switch (inst.args.length) {
case 5:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.UseDef, GP, 64);
inst.visitArg(2, func, Arg.Use, GP, 64);
inst.visitArg(3, func, Arg.UseDef, GP, 64);
inst.visitArg(4, func, Arg.ZDef, GP, 8);
break;
case 3:
inst.visitArg(0, func, Arg.UseDef, GP, 64);
inst.visitArg(1, func, Arg.Use, GP, 64);
inst.visitArg(2, func, Arg.UseDef, GP, 64);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::BranchAtomicStrongCAS8:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.UseDef, GP, 8);
inst.visitArg(2, func, Arg.Use, GP, 8);
inst.visitArg(3, func, Arg.UseDef, GP, 8);
break;
break;
case Opcode::BranchAtomicStrongCAS16:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.UseDef, GP, 16);
inst.visitArg(2, func, Arg.Use, GP, 32);
inst.visitArg(3, func, Arg.UseDef, GP, 16);
break;
break;
case Opcode::BranchAtomicStrongCAS32:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.UseDef, GP, 32);
inst.visitArg(2, func, Arg.Use, GP, 32);
inst.visitArg(3, func, Arg.UseDef, GP, 32);
break;
break;
case Opcode::BranchAtomicStrongCAS64:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.UseDef, GP, 64);
inst.visitArg(2, func, Arg.Use, GP, 64);
inst.visitArg(3, func, Arg.UseDef, GP, 64);
break;
break;
case Opcode::AtomicAdd8:
inst.visitArg(0, func, Arg.Use, GP, 8);
inst.visitArg(1, func, Arg.UseDef, GP, 8);
break;
break;
case Opcode::AtomicAdd16:
inst.visitArg(0, func, Arg.Use, GP, 16);
inst.visitArg(1, func, Arg.UseDef, GP, 16);
break;
break;
case Opcode::AtomicAdd32:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.UseDef, GP, 32);
break;
break;
case Opcode::AtomicAdd64:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.UseDef, GP, 64);
break;
break;
case Opcode::AtomicSub8:
inst.visitArg(0, func, Arg.Use, GP, 8);
inst.visitArg(1, func, Arg.UseDef, GP, 8);
break;
break;
case Opcode::AtomicSub16:
inst.visitArg(0, func, Arg.Use, GP, 16);
inst.visitArg(1, func, Arg.UseDef, GP, 16);
break;
break;
case Opcode::AtomicSub32:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.UseDef, GP, 32);
break;
break;
case Opcode::AtomicSub64:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.UseDef, GP, 64);
break;
break;
case Opcode::AtomicAnd8:
inst.visitArg(0, func, Arg.Use, GP, 8);
inst.visitArg(1, func, Arg.UseDef, GP, 8);
break;
break;
case Opcode::AtomicAnd16:
inst.visitArg(0, func, Arg.Use, GP, 16);
inst.visitArg(1, func, Arg.UseDef, GP, 16);
break;
break;
case Opcode::AtomicAnd32:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.UseDef, GP, 32);
break;
break;
case Opcode::AtomicAnd64:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.UseDef, GP, 64);
break;
break;
case Opcode::AtomicOr8:
inst.visitArg(0, func, Arg.Use, GP, 8);
inst.visitArg(1, func, Arg.UseDef, GP, 8);
break;
break;
case Opcode::AtomicOr16:
inst.visitArg(0, func, Arg.Use, GP, 16);
inst.visitArg(1, func, Arg.UseDef, GP, 16);
break;
break;
case Opcode::AtomicOr32:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.UseDef, GP, 32);
break;
break;
case Opcode::AtomicOr64:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.UseDef, GP, 64);
break;
break;
case Opcode::AtomicXor8:
inst.visitArg(0, func, Arg.Use, GP, 8);
inst.visitArg(1, func, Arg.UseDef, GP, 8);
break;
break;
case Opcode::AtomicXor16:
inst.visitArg(0, func, Arg.Use, GP, 16);
inst.visitArg(1, func, Arg.UseDef, GP, 16);
break;
break;
case Opcode::AtomicXor32:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.UseDef, GP, 32);
break;
break;
case Opcode::AtomicXor64:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.UseDef, GP, 64);
break;
break;
case Opcode::AtomicNeg8:
inst.visitArg(0, func, Arg.UseDef, GP, 8);
break;
break;
case Opcode::AtomicNeg16:
inst.visitArg(0, func, Arg.UseDef, GP, 16);
break;
break;
case Opcode::AtomicNeg32:
inst.visitArg(0, func, Arg.UseDef, GP, 32);
break;
break;
case Opcode::AtomicNeg64:
inst.visitArg(0, func, Arg.UseDef, GP, 64);
break;
break;
case Opcode::AtomicNot8:
inst.visitArg(0, func, Arg.UseDef, GP, 8);
break;
break;
case Opcode::AtomicNot16:
inst.visitArg(0, func, Arg.UseDef, GP, 16);
break;
break;
case Opcode::AtomicNot32:
inst.visitArg(0, func, Arg.UseDef, GP, 32);
break;
break;
case Opcode::AtomicNot64:
inst.visitArg(0, func, Arg.UseDef, GP, 64);
break;
break;
case Opcode::AtomicXchgAdd8:
inst.visitArg(0, func, Arg.UseDef, GP, 8);
inst.visitArg(1, func, Arg.UseDef, GP, 8);
break;
break;
case Opcode::AtomicXchgAdd16:
inst.visitArg(0, func, Arg.UseDef, GP, 16);
inst.visitArg(1, func, Arg.UseDef, GP, 16);
break;
break;
case Opcode::AtomicXchgAdd32:
inst.visitArg(0, func, Arg.UseDef, GP, 32);
inst.visitArg(1, func, Arg.UseDef, GP, 32);
break;
break;
case Opcode::AtomicXchgAdd64:
inst.visitArg(0, func, Arg.UseDef, GP, 64);
inst.visitArg(1, func, Arg.UseDef, GP, 64);
break;
break;
case Opcode::AtomicXchg8:
inst.visitArg(0, func, Arg.UseDef, GP, 8);
inst.visitArg(1, func, Arg.UseDef, GP, 8);
break;
break;
case Opcode::AtomicXchg16:
inst.visitArg(0, func, Arg.UseDef, GP, 16);
inst.visitArg(1, func, Arg.UseDef, GP, 16);
break;
break;
case Opcode::AtomicXchg32:
inst.visitArg(0, func, Arg.UseDef, GP, 32);
inst.visitArg(1, func, Arg.UseDef, GP, 32);
break;
break;
case Opcode::AtomicXchg64:
inst.visitArg(0, func, Arg.UseDef, GP, 64);
inst.visitArg(1, func, Arg.UseDef, GP, 64);
break;
break;
case Opcode::LoadLink8:
inst.visitArg(0, func, Arg.Use, GP, 8);
inst.visitArg(1, func, Arg.ZDef, GP, 8);
break;
break;
case Opcode::LoadLinkAcq8:
inst.visitArg(0, func, Arg.Use, GP, 8);
inst.visitArg(1, func, Arg.ZDef, GP, 8);
break;
break;
case Opcode::StoreCond8:
inst.visitArg(0, func, Arg.Use, GP, 8);
inst.visitArg(1, func, Arg.Def, GP, 8);
inst.visitArg(2, func, Arg.EarlyZDef, GP, 8);
break;
break;
case Opcode::StoreCondRel8:
inst.visitArg(0, func, Arg.Use, GP, 8);
inst.visitArg(1, func, Arg.Def, GP, 8);
inst.visitArg(2, func, Arg.EarlyZDef, GP, 8);
break;
break;
case Opcode::LoadLink16:
inst.visitArg(0, func, Arg.Use, GP, 16);
inst.visitArg(1, func, Arg.ZDef, GP, 16);
break;
break;
case Opcode::LoadLinkAcq16:
inst.visitArg(0, func, Arg.Use, GP, 16);
inst.visitArg(1, func, Arg.ZDef, GP, 16);
break;
break;
case Opcode::StoreCond16:
inst.visitArg(0, func, Arg.Use, GP, 16);
inst.visitArg(1, func, Arg.Def, GP, 16);
inst.visitArg(2, func, Arg.EarlyZDef, GP, 8);
break;
break;
case Opcode::StoreCondRel16:
inst.visitArg(0, func, Arg.Use, GP, 16);
inst.visitArg(1, func, Arg.Def, GP, 16);
inst.visitArg(2, func, Arg.EarlyZDef, GP, 8);
break;
break;
case Opcode::LoadLink32:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.ZDef, GP, 32);
break;
break;
case Opcode::LoadLinkAcq32:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.ZDef, GP, 32);
break;
break;
case Opcode::StoreCond32:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Def, GP, 32);
inst.visitArg(2, func, Arg.EarlyZDef, GP, 8);
break;
break;
case Opcode::StoreCondRel32:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Def, GP, 32);
inst.visitArg(2, func, Arg.EarlyZDef, GP, 8);
break;
break;
case Opcode::LoadLink64:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.ZDef, GP, 64);
break;
break;
case Opcode::LoadLinkAcq64:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.ZDef, GP, 64);
break;
break;
case Opcode::StoreCond64:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.Def, GP, 64);
inst.visitArg(2, func, Arg.EarlyZDef, GP, 8);
break;
break;
case Opcode::StoreCondRel64:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.Def, GP, 64);
inst.visitArg(2, func, Arg.EarlyZDef, GP, 8);
break;
break;
case Opcode::Depend32:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.ZDef, GP, 32);
break;
break;
case Opcode::Depend64:
inst.visitArg(0, func, Arg.Use, GP, 64);
inst.visitArg(1, func, Arg.ZDef, GP, 64);
break;
break;
case Opcode::Compare32:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 32);
inst.visitArg(2, func, Arg.Use, GP, 32);
inst.visitArg(3, func, Arg.ZDef, GP, 32);
break;
break;
case Opcode::Compare64:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 64);
inst.visitArg(2, func, Arg.Use, GP, 64);
inst.visitArg(3, func, Arg.ZDef, GP, 32);
break;
break;
case Opcode::Test32:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 32);
inst.visitArg(2, func, Arg.Use, GP, 32);
inst.visitArg(3, func, Arg.ZDef, GP, 32);
break;
break;
case Opcode::Test64:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 64);
inst.visitArg(2, func, Arg.Use, GP, 64);
inst.visitArg(3, func, Arg.ZDef, GP, 32);
break;
break;
case Opcode::CompareDouble:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, FP, 64);
inst.visitArg(2, func, Arg.Use, FP, 64);
inst.visitArg(3, func, Arg.ZDef, GP, 32);
break;
break;
case Opcode::CompareFloat:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, FP, 32);
inst.visitArg(2, func, Arg.Use, FP, 32);
inst.visitArg(3, func, Arg.ZDef, GP, 32);
break;
break;
case Opcode::Branch8:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 8);
inst.visitArg(2, func, Arg.Use, GP, 8);
break;
break;
case Opcode::Branch32:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 32);
inst.visitArg(2, func, Arg.Use, GP, 32);
break;
break;
case Opcode::Branch64:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 64);
inst.visitArg(2, func, Arg.Use, GP, 64);
break;
break;
case Opcode::BranchTest8:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 8);
inst.visitArg(2, func, Arg.Use, GP, 8);
break;
break;
case Opcode::BranchTest32:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 32);
inst.visitArg(2, func, Arg.Use, GP, 32);
break;
break;
case Opcode::BranchTest64:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 64);
inst.visitArg(2, func, Arg.Use, GP, 64);
break;
break;
case Opcode::BranchDouble:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, FP, 64);
inst.visitArg(2, func, Arg.Use, FP, 64);
break;
break;
case Opcode::BranchFloat:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, FP, 32);
inst.visitArg(2, func, Arg.Use, FP, 32);
break;
break;
case Opcode::BranchAdd32:
switch (inst.args.length) {
case 4:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 32);
inst.visitArg(2, func, Arg.Use, GP, 32);
inst.visitArg(3, func, Arg.ZDef, GP, 32);
break;
case 3:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 32);
inst.visitArg(2, func, Arg.UseZDef, GP, 32);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::BranchAdd64:
switch (inst.args.length) {
case 4:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 64);
inst.visitArg(2, func, Arg.Use, GP, 64);
inst.visitArg(3, func, Arg.ZDef, GP, 64);
break;
case 3:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 64);
inst.visitArg(2, func, Arg.UseDef, GP, 64);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::BranchMul32:
switch (inst.args.length) {
case 3:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 32);
inst.visitArg(2, func, Arg.UseZDef, GP, 32);
break;
case 4:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 32);
inst.visitArg(2, func, Arg.Use, GP, 32);
inst.visitArg(3, func, Arg.ZDef, GP, 32);
break;
case 6:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 32);
inst.visitArg(2, func, Arg.Use, GP, 32);
inst.visitArg(3, func, Arg.Scratch, GP, 32);
inst.visitArg(4, func, Arg.Scratch, GP, 32);
inst.visitArg(5, func, Arg.ZDef, GP, 32);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::BranchMul64:
switch (inst.args.length) {
case 3:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 64);
inst.visitArg(2, func, Arg.UseZDef, GP, 64);
break;
case 6:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 64);
inst.visitArg(2, func, Arg.Use, GP, 64);
inst.visitArg(3, func, Arg.Scratch, GP, 64);
inst.visitArg(4, func, Arg.Scratch, GP, 64);
inst.visitArg(5, func, Arg.ZDef, GP, 64);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::BranchSub32:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 32);
inst.visitArg(2, func, Arg.UseZDef, GP, 32);
break;
break;
case Opcode::BranchSub64:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 64);
inst.visitArg(2, func, Arg.UseDef, GP, 64);
break;
break;
case Opcode::BranchNeg32:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.UseZDef, GP, 32);
break;
break;
case Opcode::BranchNeg64:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.UseZDef, GP, 64);
break;
break;
case Opcode::MoveConditionally32:
switch (inst.args.length) {
case 5:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 32);
inst.visitArg(2, func, Arg.Use, GP, 32);
inst.visitArg(3, func, Arg.Use, GP, Ptr);
inst.visitArg(4, func, Arg.UseDef, GP, Ptr);
break;
case 6:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 32);
inst.visitArg(2, func, Arg.Use, GP, 32);
inst.visitArg(3, func, Arg.Use, GP, Ptr);
inst.visitArg(4, func, Arg.Use, GP, Ptr);
inst.visitArg(5, func, Arg.Def, GP, Ptr);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::MoveConditionally64:
switch (inst.args.length) {
case 5:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 64);
inst.visitArg(2, func, Arg.Use, GP, 64);
inst.visitArg(3, func, Arg.Use, GP, Ptr);
inst.visitArg(4, func, Arg.UseDef, GP, Ptr);
break;
case 6:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 64);
inst.visitArg(2, func, Arg.Use, GP, 64);
inst.visitArg(3, func, Arg.Use, GP, Ptr);
inst.visitArg(4, func, Arg.Use, GP, Ptr);
inst.visitArg(5, func, Arg.Def, GP, Ptr);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::MoveConditionallyTest32:
switch (inst.args.length) {
case 5:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 32);
inst.visitArg(2, func, Arg.Use, GP, 32);
inst.visitArg(3, func, Arg.Use, GP, Ptr);
inst.visitArg(4, func, Arg.UseDef, GP, Ptr);
break;
case 6:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 32);
inst.visitArg(2, func, Arg.Use, GP, 32);
inst.visitArg(3, func, Arg.Use, GP, Ptr);
inst.visitArg(4, func, Arg.Use, GP, Ptr);
inst.visitArg(5, func, Arg.Def, GP, Ptr);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::MoveConditionallyTest64:
switch (inst.args.length) {
case 5:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 64);
inst.visitArg(2, func, Arg.Use, GP, 64);
inst.visitArg(3, func, Arg.Use, GP, Ptr);
inst.visitArg(4, func, Arg.UseDef, GP, Ptr);
break;
case 6:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 32);
inst.visitArg(2, func, Arg.Use, GP, 32);
inst.visitArg(3, func, Arg.Use, GP, Ptr);
inst.visitArg(4, func, Arg.Use, GP, Ptr);
inst.visitArg(5, func, Arg.Def, GP, Ptr);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::MoveConditionallyDouble:
switch (inst.args.length) {
case 6:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, FP, 64);
inst.visitArg(2, func, Arg.Use, FP, 64);
inst.visitArg(3, func, Arg.Use, GP, Ptr);
inst.visitArg(4, func, Arg.Use, GP, Ptr);
inst.visitArg(5, func, Arg.Def, GP, Ptr);
break;
case 5:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, FP, 64);
inst.visitArg(2, func, Arg.Use, FP, 64);
inst.visitArg(3, func, Arg.Use, GP, Ptr);
inst.visitArg(4, func, Arg.UseDef, GP, Ptr);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::MoveConditionallyFloat:
switch (inst.args.length) {
case 6:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, FP, 32);
inst.visitArg(2, func, Arg.Use, FP, 32);
inst.visitArg(3, func, Arg.Use, GP, Ptr);
inst.visitArg(4, func, Arg.Use, GP, Ptr);
inst.visitArg(5, func, Arg.Def, GP, Ptr);
break;
case 5:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, FP, 32);
inst.visitArg(2, func, Arg.Use, FP, 32);
inst.visitArg(3, func, Arg.Use, GP, Ptr);
inst.visitArg(4, func, Arg.UseDef, GP, Ptr);
break;
default:
throw new Error("Bad overload");
break;
}
break;
case Opcode::MoveDoubleConditionally32:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 32);
inst.visitArg(2, func, Arg.Use, GP, 32);
inst.visitArg(3, func, Arg.Use, FP, 64);
inst.visitArg(4, func, Arg.Use, FP, 64);
inst.visitArg(5, func, Arg.Def, FP, 64);
break;
break;
case Opcode::MoveDoubleConditionally64:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 64);
inst.visitArg(2, func, Arg.Use, GP, 64);
inst.visitArg(3, func, Arg.Use, FP, 64);
inst.visitArg(4, func, Arg.Use, FP, 64);
inst.visitArg(5, func, Arg.Def, FP, 64);
break;
break;
case Opcode::MoveDoubleConditionallyTest32:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 32);
inst.visitArg(2, func, Arg.Use, GP, 32);
inst.visitArg(3, func, Arg.Use, FP, 64);
inst.visitArg(4, func, Arg.Use, FP, 64);
inst.visitArg(5, func, Arg.Def, FP, 64);
break;
break;
case Opcode::MoveDoubleConditionallyTest64:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, GP, 64);
inst.visitArg(2, func, Arg.Use, GP, 64);
inst.visitArg(3, func, Arg.Use, FP, 64);
inst.visitArg(4, func, Arg.Use, FP, 64);
inst.visitArg(5, func, Arg.Def, FP, 64);
break;
break;
case Opcode::MoveDoubleConditionallyDouble:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, FP, 64);
inst.visitArg(2, func, Arg.Use, FP, 64);
inst.visitArg(3, func, Arg.Use, FP, 64);
inst.visitArg(4, func, Arg.Use, FP, 64);
inst.visitArg(5, func, Arg.Def, FP, 64);
break;
break;
case Opcode::MoveDoubleConditionallyFloat:
inst.visitArg(0, func, Arg.Use, GP, 32);
inst.visitArg(1, func, Arg.Use, FP, 32);
inst.visitArg(2, func, Arg.Use, FP, 32);
inst.visitArg(3, func, Arg.Use, FP, 64);
inst.visitArg(4, func, Arg.Use, FP, 64);
inst.visitArg(5, func, Arg.Def, FP, 64);
break;
break;
case Opcode::MemoryFence:
break;
break;
case Opcode::StoreFence:
break;
break;
case Opcode::LoadFence:
break;
break;
case Opcode::Jump:
break;
break;
case Opcode::RetVoid:
break;
break;
case Opcode::Ret32:
inst.visitArg(0, func, Arg.Use, GP, 32);
break;
break;
case Opcode::Ret64:
inst.visitArg(0, func, Arg.Use, GP, 64);
break;
break;
case Opcode::RetFloat:
inst.visitArg(0, func, Arg.Use, FP, 32);
break;
break;
case Opcode::RetDouble:
inst.visitArg(0, func, Arg.Use, FP, 64);
break;
break;
case Opcode::Oops:
break;
break;
case Opcode::EntrySwitch:
EntrySwitchCustom.forEachArg(inst, func);
break;
case Opcode::Shuffle:
ShuffleCustom.forEachArg(inst, func);
break;
case Opcode::Patch:
PatchCustom.forEachArg(inst, func);
break;
case Opcode::CCall:
CCallCustom.forEachArg(inst, func);
break;
case Opcode::ColdCCall:
ColdCCallCustom.forEachArg(inst, func);
break;
case Opcode::WasmBoundsCheck:
WasmBoundsCheckCustom.forEachArg(inst, func);
break;
default:
throw "Bad opcode";
}
}
function Inst_hasNonArgEffects(inst)
{
switch (inst.opcode) {
case Opcode::LoadAcq8:
case Opcode::StoreRel8:
case Opcode::LoadAcq8SignedExtendTo32:
case Opcode::LoadAcq16:
case Opcode::LoadAcq16SignedExtendTo32:
case Opcode::StoreRel16:
case Opcode::LoadAcq32:
case Opcode::StoreRel32:
case Opcode::LoadAcq64:
case Opcode::StoreRel64:
case Opcode::AtomicStrongCAS8:
case Opcode::AtomicStrongCAS16:
case Opcode::AtomicStrongCAS32:
case Opcode::AtomicStrongCAS64:
case Opcode::BranchAtomicStrongCAS8:
case Opcode::BranchAtomicStrongCAS16:
case Opcode::BranchAtomicStrongCAS32:
case Opcode::BranchAtomicStrongCAS64:
case Opcode::AtomicAdd8:
case Opcode::AtomicAdd16:
case Opcode::AtomicAdd32:
case Opcode::AtomicAdd64:
case Opcode::AtomicSub8:
case Opcode::AtomicSub16:
case Opcode::AtomicSub32:
case Opcode::AtomicSub64:
case Opcode::AtomicAnd8:
case Opcode::AtomicAnd16:
case Opcode::AtomicAnd32:
case Opcode::AtomicAnd64:
case Opcode::AtomicOr8:
case Opcode::AtomicOr16:
case Opcode::AtomicOr32:
case Opcode::AtomicOr64:
case Opcode::AtomicXor8:
case Opcode::AtomicXor16:
case Opcode::AtomicXor32:
case Opcode::AtomicXor64:
case Opcode::AtomicNeg8:
case Opcode::AtomicNeg16:
case Opcode::AtomicNeg32:
case Opcode::AtomicNeg64:
case Opcode::AtomicNot8:
case Opcode::AtomicNot16:
case Opcode::AtomicNot32:
case Opcode::AtomicNot64:
case Opcode::AtomicXchgAdd8:
case Opcode::AtomicXchgAdd16:
case Opcode::AtomicXchgAdd32:
case Opcode::AtomicXchgAdd64:
case Opcode::AtomicXchg8:
case Opcode::AtomicXchg16:
case Opcode::AtomicXchg32:
case Opcode::AtomicXchg64:
case Opcode::LoadLink8:
case Opcode::LoadLinkAcq8:
case Opcode::StoreCond8:
case Opcode::StoreCondRel8:
case Opcode::LoadLink16:
case Opcode::LoadLinkAcq16:
case Opcode::StoreCond16:
case Opcode::StoreCondRel16:
case Opcode::LoadLink32:
case Opcode::LoadLinkAcq32:
case Opcode::StoreCond32:
case Opcode::StoreCondRel32:
case Opcode::LoadLink64:
case Opcode::LoadLinkAcq64:
case Opcode::StoreCond64:
case Opcode::StoreCondRel64:
case Opcode::Branch8:
case Opcode::Branch32:
case Opcode::Branch64:
case Opcode::BranchTest8:
case Opcode::BranchTest32:
case Opcode::BranchTest64:
case Opcode::BranchDouble:
case Opcode::BranchFloat:
case Opcode::BranchAdd32:
case Opcode::BranchAdd64:
case Opcode::BranchMul32:
case Opcode::BranchMul64:
case Opcode::BranchSub32:
case Opcode::BranchSub64:
case Opcode::BranchNeg32:
case Opcode::BranchNeg64:
case Opcode::MemoryFence:
case Opcode::StoreFence:
case Opcode::LoadFence:
case Opcode::Jump:
case Opcode::RetVoid:
case Opcode::Ret32:
case Opcode::Ret64:
case Opcode::RetFloat:
case Opcode::RetDouble:
case Opcode::Oops:
return true;
case Opcode::EntrySwitch:
return EntrySwitchCustom.hasNonArgNonControlEffects(inst);
case Opcode::Shuffle:
return ShuffleCustom.hasNonArgNonControlEffects(inst);
case Opcode::Patch:
return PatchCustom.hasNonArgNonControlEffects(inst);
case Opcode::CCall:
return CCallCustom.hasNonArgNonControlEffects(inst);
case Opcode::ColdCCall:
return ColdCCallCustom.hasNonArgNonControlEffects(inst);
case Opcode::WasmBoundsCheck:
return WasmBoundsCheckCustom.hasNonArgNonControlEffects(inst);
default:
return false;
}
}
function opcodeCode(opcode)
{
switch (opcode) {
case Opcode::AbsDouble:
return 0
case Opcode::AbsFloat:
return 1
case Opcode::Add16:
return 2
case Opcode::Add32:
return 3
case Opcode::Add64:
return 4
case Opcode::Add8:
return 5
case Opcode::AddDouble:
return 6
case Opcode::AddFloat:
return 7
case Opcode::And32:
return 8
case Opcode::And64:
return 9
case Opcode::AndDouble:
return 10
case Opcode::AndFloat:
return 11
case Opcode::AtomicAdd16:
return 12
case Opcode::AtomicAdd32:
return 13
case Opcode::AtomicAdd64:
return 14
case Opcode::AtomicAdd8:
return 15
case Opcode::AtomicAnd16:
return 16
case Opcode::AtomicAnd32:
return 17
case Opcode::AtomicAnd64:
return 18
case Opcode::AtomicAnd8:
return 19
case Opcode::AtomicNeg16:
return 20
case Opcode::AtomicNeg32:
return 21
case Opcode::AtomicNeg64:
return 22
case Opcode::AtomicNeg8:
return 23
case Opcode::AtomicNot16:
return 24
case Opcode::AtomicNot32:
return 25
case Opcode::AtomicNot64:
return 26
case Opcode::AtomicNot8:
return 27
case Opcode::AtomicOr16:
return 28
case Opcode::AtomicOr32:
return 29
case Opcode::AtomicOr64:
return 30
case Opcode::AtomicOr8:
return 31
case Opcode::AtomicStrongCAS16:
return 32
case Opcode::AtomicStrongCAS32:
return 33
case Opcode::AtomicStrongCAS64:
return 34
case Opcode::AtomicStrongCAS8:
return 35
case Opcode::AtomicSub16:
return 36
case Opcode::AtomicSub32:
return 37
case Opcode::AtomicSub64:
return 38
case Opcode::AtomicSub8:
return 39
case Opcode::AtomicXchg16:
return 40
case Opcode::AtomicXchg32:
return 41
case Opcode::AtomicXchg64:
return 42
case Opcode::AtomicXchg8:
return 43
case Opcode::AtomicXchgAdd16:
return 44
case Opcode::AtomicXchgAdd32:
return 45
case Opcode::AtomicXchgAdd64:
return 46
case Opcode::AtomicXchgAdd8:
return 47
case Opcode::AtomicXor16:
return 48
case Opcode::AtomicXor32:
return 49
case Opcode::AtomicXor64:
return 50
case Opcode::AtomicXor8:
return 51
case Opcode::Branch32:
return 52
case Opcode::Branch64:
return 53
case Opcode::Branch8:
return 54
case Opcode::BranchAdd32:
return 55
case Opcode::BranchAdd64:
return 56
case Opcode::BranchAtomicStrongCAS16:
return 57
case Opcode::BranchAtomicStrongCAS32:
return 58
case Opcode::BranchAtomicStrongCAS64:
return 59
case Opcode::BranchAtomicStrongCAS8:
return 60
case Opcode::BranchDouble:
return 61
case Opcode::BranchFloat:
return 62
case Opcode::BranchMul32:
return 63
case Opcode::BranchMul64:
return 64
case Opcode::BranchNeg32:
return 65
case Opcode::BranchNeg64:
return 66
case Opcode::BranchSub32:
return 67
case Opcode::BranchSub64:
return 68
case Opcode::BranchTest32:
return 69
case Opcode::BranchTest64:
return 70
case Opcode::BranchTest8:
return 71
case Opcode::CCall:
return 72
case Opcode::CeilDouble:
return 73
case Opcode::CeilFloat:
return 74
case Opcode::ColdCCall:
return 75
case Opcode::Compare32:
return 76
case Opcode::Compare64:
return 77
case Opcode::CompareDouble:
return 78
case Opcode::CompareFloat:
return 79
case Opcode::ConvertDoubleToFloat:
return 80
case Opcode::ConvertFloatToDouble:
return 81
case Opcode::ConvertInt32ToDouble:
return 82
case Opcode::ConvertInt32ToFloat:
return 83
case Opcode::ConvertInt64ToDouble:
return 84
case Opcode::ConvertInt64ToFloat:
return 85
case Opcode::CountLeadingZeros32:
return 86
case Opcode::CountLeadingZeros64:
return 87
case Opcode::Depend32:
return 88
case Opcode::Depend64:
return 89
case Opcode::Div32:
return 90
case Opcode::Div64:
return 91
case Opcode::DivDouble:
return 92
case Opcode::DivFloat:
return 93
case Opcode::EntrySwitch:
return 94
case Opcode::FloorDouble:
return 95
case Opcode::FloorFloat:
return 96
case Opcode::Jump:
return 97
case Opcode::Lea32:
return 98
case Opcode::Lea64:
return 99
case Opcode::Load16:
return 100
case Opcode::Load16SignedExtendTo32:
return 101
case Opcode::Load8:
return 102
case Opcode::Load8SignedExtendTo32:
return 103
case Opcode::LoadAcq16:
return 104
case Opcode::LoadAcq16SignedExtendTo32:
return 105
case Opcode::LoadAcq32:
return 106
case Opcode::LoadAcq64:
return 107
case Opcode::LoadAcq8:
return 108
case Opcode::LoadAcq8SignedExtendTo32:
return 109
case Opcode::LoadFence:
return 110
case Opcode::LoadLink16:
return 111
case Opcode::LoadLink32:
return 112
case Opcode::LoadLink64:
return 113
case Opcode::LoadLink8:
return 114
case Opcode::LoadLinkAcq16:
return 115
case Opcode::LoadLinkAcq32:
return 116
case Opcode::LoadLinkAcq64:
return 117
case Opcode::LoadLinkAcq8:
return 118
case Opcode::Lshift32:
return 119
case Opcode::Lshift64:
return 120
case Opcode::MemoryFence:
return 121
case Opcode::Move:
return 122
case Opcode::Move32:
return 123
case Opcode::Move32ToFloat:
return 124
case Opcode::Move64ToDouble:
return 125
case Opcode::MoveConditionally32:
return 126
case Opcode::MoveConditionally64:
return 127
case Opcode::MoveConditionallyDouble:
return 128
case Opcode::MoveConditionallyFloat:
return 129
case Opcode::MoveConditionallyTest32:
return 130
case Opcode::MoveConditionallyTest64:
return 131
case Opcode::MoveDouble:
return 132
case Opcode::MoveDoubleConditionally32:
return 133
case Opcode::MoveDoubleConditionally64:
return 134
case Opcode::MoveDoubleConditionallyDouble:
return 135
case Opcode::MoveDoubleConditionallyFloat:
return 136
case Opcode::MoveDoubleConditionallyTest32:
return 137
case Opcode::MoveDoubleConditionallyTest64:
return 138
case Opcode::MoveDoubleTo64:
return 139
case Opcode::MoveFloat:
return 140
case Opcode::MoveFloatTo32:
return 141
case Opcode::MoveZeroToDouble:
return 142
case Opcode::Mul32:
return 143
case Opcode::Mul64:
return 144
case Opcode::MulDouble:
return 145
case Opcode::MulFloat:
return 146
case Opcode::MultiplyAdd32:
return 147
case Opcode::MultiplyAdd64:
return 148
case Opcode::MultiplyNeg32:
return 149
case Opcode::MultiplyNeg64:
return 150
case Opcode::MultiplySub32:
return 151
case Opcode::MultiplySub64:
return 152
case Opcode::Neg32:
return 153
case Opcode::Neg64:
return 154
case Opcode::NegateDouble:
return 155
case Opcode::NegateFloat:
return 156
case Opcode::Nop:
return 157
case Opcode::Not32:
return 158
case Opcode::Not64:
return 159
case Opcode::Oops:
return 160
case Opcode::Or32:
return 161
case Opcode::Or64:
return 162
case Opcode::OrDouble:
return 163
case Opcode::OrFloat:
return 164
case Opcode::Patch:
return 165
case Opcode::Ret32:
return 166
case Opcode::Ret64:
return 167
case Opcode::RetDouble:
return 168
case Opcode::RetFloat:
return 169
case Opcode::RetVoid:
return 170
case Opcode::RotateLeft32:
return 171
case Opcode::RotateLeft64:
return 172
case Opcode::RotateRight32:
return 173
case Opcode::RotateRight64:
return 174
case Opcode::Rshift32:
return 175
case Opcode::Rshift64:
return 176
case Opcode::Shuffle:
return 177
case Opcode::SignExtend16To32:
return 178
case Opcode::SignExtend32ToPtr:
return 179
case Opcode::SignExtend8To32:
return 180
case Opcode::SqrtDouble:
return 181
case Opcode::SqrtFloat:
return 182
case Opcode::Store16:
return 183
case Opcode::Store8:
return 184
case Opcode::StoreCond16:
return 185
case Opcode::StoreCond32:
return 186
case Opcode::StoreCond64:
return 187
case Opcode::StoreCond8:
return 188
case Opcode::StoreCondRel16:
return 189
case Opcode::StoreCondRel32:
return 190
case Opcode::StoreCondRel64:
return 191
case Opcode::StoreCondRel8:
return 192
case Opcode::StoreFence:
return 193
case Opcode::StoreRel16:
return 194
case Opcode::StoreRel32:
return 195
case Opcode::StoreRel64:
return 196
case Opcode::StoreRel8:
return 197
case Opcode::StoreZero32:
return 198
case Opcode::Sub32:
return 199
case Opcode::Sub64:
return 200
case Opcode::SubDouble:
return 201
case Opcode::SubFloat:
return 202
case Opcode::Swap32:
return 203
case Opcode::Swap64:
return 204
case Opcode::Test32:
return 205
case Opcode::Test64:
return 206
case Opcode::UDiv32:
return 207
case Opcode::UDiv64:
return 208
case Opcode::Urshift32:
return 209
case Opcode::Urshift64:
return 210
case Opcode::WasmBoundsCheck:
return 211
case Opcode::X86ConvertToDoubleWord32:
return 212
case Opcode::X86ConvertToQuadWord64:
return 213
case Opcode::X86Div32:
return 214
case Opcode::X86Div64:
return 215
case Opcode::X86UDiv32:
return 216
case Opcode::X86UDiv64:
return 217
case Opcode::Xor32:
return 218
case Opcode::Xor64:
return 219
case Opcode::XorDouble:
return 220
case Opcode::XorFloat:
return 221
case Opcode::ZeroExtend16To32:
return 222
case Opcode::ZeroExtend8To32:
return 223
default:
throw new Error("bad opcode");
}
}
